[
  {
    "type": "Coding",
    "title": "接雨水",
    "category": [
      "LeetCode",
      "Array",
      "Dynamic Programming",
      "Stack",
      "Two Pointers"
    ],
    "difficulty": "Hard"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "Data Structures",
      "数据结构",
      "Redis"
    ],
    "difficulty": "Medium",
    "title": "ZSET表的原理，怎么实现的用户登录限流，表占用过大时是手动还是自动删除数据，占用上限是如何设置的"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络"
    ],
    "difficulty": "Hard",
    "title": "Epoll的原理"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Tree",
      "树"
    ],
    "difficulty": "Hard",
    "title": "红黑树的原理，在Epoll中红黑树的键值分别是什么"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络"
    ],
    "difficulty": "Hard",
    "title": "epoll_wait返回的队列是由谁将事件加入队列的"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池有几个分别是什么作用"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "Linux中的硬连接和软连接，硬连接软连接可以比作哪些智能指针"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "虚拟内存，不同操作系统下页表是几级"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "中断机制是怎么处理的"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "Dynamic Programming",
      "动态规划",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "最长公共子序列"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "String",
      "字符串",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "无重复最长子串"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "UDP"
    ],
    "difficulty": "Medium",
    "title": "TCP和UDP的区别"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "Array",
      "数组",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "区间合并"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Golang",
      "Go"
    ],
    "difficulty": "Medium",
    "title": "进程线程协程，gmp调度？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "乐观锁和悲观锁？讲讲怎么实现？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "死锁的条件？解决办法？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "MySQL事务特性以及实现"
  },
  {
    "type": "Question",
    "category": [
      "System Design",
      "系统设计"
    ],
    "difficulty": "Hard",
    "title": "如果你的项目有千万级的用户量，你怎么优化"
  },
  {
    "type": "Question",
    "category": [
      "Design Patterns",
      "设计模式"
    ],
    "difficulty": "Easy",
    "title": "设计模式了解过哪些"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "Graph",
      "图",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "岛屿数量"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "UDP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "TCP和UDP区别，HTTP用的谁，为什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "HTTP状态码"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "TCP",
      "UDP"
    ],
    "difficulty": "Medium",
    "title": "HTTP是长连接还是短连接，如何用UDP实现"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "MySQL索引如何实现的。"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "MySQL索引为什么用B+不用B树？如果把内容存在内存上，用B树会不会快一点。"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "分库分表的常用中间件有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Hard",
    "title": "有哪些问题中间件无法提供帮助、只能改写业务代码的场景？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "MySQL",
      "分库分表"
    ],
    "difficulty": "Easy",
    "title": "分库分表使用了什么中间件？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Medium",
    "title": "分库分表的实现场景和方式有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Medium",
    "title": "分表之后，要查询两个表的数据要怎么查？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Medium",
    "title": "分库分表的优缺点是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Hard",
    "title": "分库分表业界有哪些替代方案？（提示：分布式文件系统，因为分库分表会出现降低QPS，比如range查询失效）"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Hard",
    "title": "为什么做了分库分表后分页比较困难了？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Hard",
    "title": "如果10亿数据要分表，要怎么分？业务怎么切？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "Concurrency",
      "并发",
      "分库分表"
    ],
    "difficulty": "Hard",
    "title": "分库分表怎么保证数据一致性？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Medium",
    "title": "分库分表选的什么分片键？什么分片算法？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Medium",
    "title": "分库分表后的分布式ID怎么做？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Concurrency",
      "并发",
      "动态代理"
    ],
    "difficulty": "Medium",
    "title": "JDK和Cglib动态代理有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Array",
      "数组",
      "Linked List",
      "链表",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "ArrayList和LinkedList的区别？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Hash Table",
      "哈希表",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "HashMap原理?"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Tree",
      "树",
      "Binary Search Tree",
      "二叉搜索树",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "红黑树红和黑代表什么?"
  },
  {
    "type": "Coding",
    "category": [
      "Data Structures",
      "数据结构",
      "Hash Table",
      "哈希表",
      "Array",
      "数组",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "HashMap数组索引怎么确认？"
  },
  {
    "type": "Question",
    "category": [
      "Algorithms",
      "算法",
      "Hash Table",
      "哈希表",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "常见的哈希算法了解哪些？解决哈希冲突的方法?"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "Java有什么集合容器？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Tree",
      "树",
      "Sorting",
      "排序",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "Treemap怎么排序，有什么注意事项，可不可以自定义排序，排序的数据结构是什么"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Concurrency",
      "并发",
      "Array",
      "数组",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "CopyOnWriteArrayList怎么保证线程安全，优点是这个，那缺点呢？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Concurrency",
      "并发",
      "Array",
      "数组",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "ArrayList线程安全吗，想要使用线程安全的ArrayList怎么办？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Hash Table",
      "哈希表",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "假设你要遍历一个 HashMap，同时删除一些 key，应该怎么编写代码？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Concurrency",
      "并发",
      "Hash Table",
      "哈希表",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "HashTable怎么保证线程安全的，ConcurrentHashMap呢，怎么去选择呢"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Hash Table",
      "哈希表",
      "Tree",
      "树",
      "Binary Search Tree",
      "二叉搜索树",
      "Java"
    ],
    "difficulty": "Hard",
    "title": "Hashmap 为什么选择红黑树而不是AVL"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Reflection",
      "反射"
    ],
    "difficulty": "Medium",
    "title": "你对Java的反射如何理解的，原理是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Reflection",
      "反射"
    ],
    "difficulty": "Medium",
    "title": "反射机制对于其他没有反射的语言有什么好处？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Reflection",
      "反射"
    ],
    "difficulty": "Medium",
    "title": "Java中哪些效率高的功能是基于反射做的呢？"
  },
  {
    "type": "Question",
    "category": [
      "String",
      "字符串",
      "Java",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "byte怎么转字符串？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Reflection",
      "反射"
    ],
    "difficulty": "Medium",
    "title": "反射的应用场景"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Reflection",
      "反射"
    ],
    "difficulty": "Medium",
    "title": "反射为什么性能开销高"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "volatile 关键字的作用是什么？不加这个关键字对变量修改就不会加到主存吗？加了这个关键字还需要加锁吗？这个关键字的一些应用场景都有哪些呢？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池",
      "Java"
    ],
    "difficulty": "Hard",
    "title": "假设让你写一个线程池工具，你觉得应该怎么去设计呢？应该有什么变量？有什么接口？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "比如核心线程数量是5，最大线程是10，现在来了11个任务，怎么调度？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "线程池的执行流程?"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "线程池是否会出现并发安全问题?"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "动态线程池是怎么实现的？动态调整机制是什么？我们应该设置多少核心线程数和最大线程数，以及通过哪里去设置？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "动态线程池的“动态”体现在什么地方？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池过程和原理"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "你怎么实际计算需要的核心线程数目和阻塞队列大小?你怎么设定拒绝策略?高请求下有的用户的请求被拒绝了，你会怎么处理反映给用户?"
  },
  {
    "type": "Question",
    "category": [
      "String",
      "字符串",
      "Java",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "String，StringBuilder，StringBuffer的区别?"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "synchronized和reentrantlock的区别？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "java乐观锁和悲观锁？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "Java 有哪些重要的锁？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Hard",
    "title": "AQS实现"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "有了synchornized为什么还会出现lock"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Operating System",
      "操作系统",
      "多线程",
      "Multi Threading"
    ],
    "difficulty": "Medium",
    "title": "多进程、多线程、多协程各自的优势和劣势？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "多线程",
      "Multi Threading"
    ],
    "difficulty": "Easy",
    "title": "Java有哪些线程状态？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Operating System",
      "操作系统",
      "Java",
      "Multi Threading"
    ],
    "difficulty": "Medium",
    "title": "如果一个进程创建了几万个线程会出现什么问题？"
  },
  {
    "type": "Coding",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Multi Threading",
      "多线程"
    ],
    "difficulty": "Medium",
    "title": "怎么让两个线程有序执行？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "多线程如何做同步"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "线程的上下文切换需要切换什么东西"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "completablefuture 和 futuretask"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "Java线程怎么进入阻塞状态"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "Java线程怎么进入Runnable状态"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Operating System",
      "操作系统",
      "Java"
    ],
    "difficulty": "Hard",
    "title": "Java线程上下文切换具体过程"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Medium",
    "title": "如果让你调研是否要从Java 8升级到更新的版本（如11或17），你会如何评估其必要性？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Medium",
    "title": "BigDecimal怎么存储，怎么计算，有什么注意事项，为什么他能保证不丢失"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Design Patterns",
      "设计模式"
    ],
    "difficulty": "Medium",
    "title": "JDK Proxy 和 CGLib Proxy 的区别"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Easy",
    "title": "Java中你遇到过哪些异常？你分别怎么处理？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Medium",
    "title": "团队升级JDK版本的话你怎么调研？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Hard",
    "title": "Java分配大对象怎么进行性能优化"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Generics",
      "泛型"
    ],
    "difficulty": "Medium",
    "title": "泛型、反射和类型推断的关系"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Algorithms",
      "算法",
      "前端",
      "Front End"
    ],
    "difficulty": "Easy",
    "title": "前端常见的数据结构有哪些？有什么基础算法？有什么应用场景？"
  },
  {
    "type": "Question",
    "category": [
      "Algorithms",
      "算法"
    ],
    "difficulty": "Easy",
    "title": "什么是时间复杂度？"
  },
  {
    "type": "Question",
    "category": [
      "Algorithms",
      "算法"
    ],
    "difficulty": "Easy",
    "title": "什么是空间复杂度？"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "两数之和"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "买卖股票的最佳时机"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "盛水最多的容器"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "除自身以外数组的乘积"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "无重复字符的最长子串"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Easy",
    "title": "验证回文串"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "反转字符串中的单词"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "手写深拷贝"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Easy",
    "title": "手写 getType 函数"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 class 继承"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "使用 ES6 语法写出三种菜单的 class"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写防抖 Debounce"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写截流 Throttle"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 bind"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 call 和 apply"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 EventBus 自定义事件"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写数组拍平 Array Flatten"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写解析 URL 参数为 JS 对象"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法"
    ],
    "difficulty": "Easy",
    "title": "手写数组去重"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法"
    ],
    "difficulty": "Medium",
    "title": "手写红绿灯"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Hard",
    "title": "手写 Promise"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Hard",
    "title": "手写 Promise.all"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Hard",
    "title": "手写 Promise.race"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Hard",
    "title": "手写 Promise.allSettled"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Hard",
    "title": "手写一个 LazyMan 实现 sleep 机制"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 curry 函数，实现函数柯里化"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 compose 函数"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "Data Structures",
      "数据结构",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "手写一个 LRU 缓存"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End",
      "Vue"
    ],
    "difficulty": "Medium",
    "title": "使用 Vue3 Composable 组合式函数，实现 useCount"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End",
      "Vue"
    ],
    "difficulty": "Medium",
    "title": "使用 Vue3 Composable 组合式函数，实现 useRequest"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End",
      "React"
    ],
    "difficulty": "Medium",
    "title": "使用 React Hook 实现 useCount"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End",
      "React"
    ],
    "difficulty": "Medium",
    "title": "使用 React Hook 实现 useRequest"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "进程和线程的区别"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "进程间的通信"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "单核 CPU 如何实现并发"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "CPU 调度算法有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Linux"
    ],
    "difficulty": "Medium",
    "title": "linux 如何查找你的进程占用的那个端口"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "单核服务器连接数超载了怎么办"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题",
      "Operating System",
      "操作系统",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "请简述一个编译器的执行过程。前端有哪些常见的编译工具？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题"
    ],
    "difficulty": "Medium",
    "title": "什么是编译型语言和解释型语言，他们有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "String",
      "字符串",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "简述 JS 垃圾回收的过程。用什么算法？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "什么是内存泄漏？如何排查？JS 内存泄漏的常见原因？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "简述 JS 运行时的堆栈内存模型？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题"
    ],
    "difficulty": "Medium",
    "title": "冯·诺依曼架构是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题"
    ],
    "difficulty": "Medium",
    "title": "计算机内部为何使用二进制？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题"
    ],
    "difficulty": "Medium",
    "title": "二进制如何表示负数和小数？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "什么是虚拟内存，为何要使用虚拟内存？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题"
    ],
    "difficulty": "Medium",
    "title": "什么是 Unicode 编码？它和常见的 UTF-8 有什么关系？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络"
    ],
    "difficulty": "Medium",
    "title": "简述计算机网络的 OSI 模型"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络"
    ],
    "difficulty": "Easy",
    "title": "一个域名对应一个 ip 吗"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络"
    ],
    "difficulty": "Medium",
    "title": "UDP 和 TCP 协议的区别？有什么应用场景"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Array",
      "数组",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "数组和链表有什么区别？从内存结构上来说"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "进程和线程的区别"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "进程间的通信"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "单核 CPU 如何实现并发"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "CPU 调度算法有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "linux 如何查找你的进程占用的那个端口"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "单核服务器连接数超载了怎么办"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "请简述一个编译器的执行过程。前端有哪些常见的编译工具？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "什么是编译型语言和解释型语言，他们有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "简述 JS 垃圾回收的过程。用什么算法？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "什么是内存泄漏？如何排查？JS 内存泄漏的常见原因？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Basic Concepts",
      "基本概念"
    ],
    "difficulty": "Easy",
    "title": "DOCTYPE 是什么，都有哪些属性？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Meta",
      "元数据"
    ],
    "difficulty": "Easy",
    "title": "meta 标签是干什么的，都有什么属性和作用"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "DOM",
      "文档对象模型"
    ],
    "difficulty": "Easy",
    "title": "什么是 DOM ，它和 HTML 有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Semantic HTML",
      "语义化HTML"
    ],
    "difficulty": "Medium",
    "title": "如何理解 HTML5 语义化 ？有哪些常见的语义化标签？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "DOM",
      "文档对象模型",
      "Attributes vs Properties"
    ],
    "difficulty": "Medium",
    "title": "DOM 节点的 attr 和 property 有何区别"
  },
  {
    "type": "Coding",
    "category": [
      "HTML",
      "HTML",
      "DOM Manipulation",
      "DOM操作"
    ],
    "difficulty": "Medium",
    "title": "如何一次性插入多个 DOM 节点？考虑性能"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "DOM",
      "文档对象模型",
      "Dimensions"
    ],
    "difficulty": "Easy",
    "title": "offsetHeight scrollHeight clientHeight 有什么区别"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "DOM",
      "文档对象模型",
      "Collections"
    ],
    "difficulty": "Medium",
    "title": "HTMLCollection 和 NodeList 的区别"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "DOM",
      "文档对象模型",
      "Nodes"
    ],
    "difficulty": "Easy",
    "title": "Node 和 Element 有什么区别？"
  },
  {
    "type": "Coding",
    "category": [
      "HTML",
      "HTML",
      "Event Handling",
      "事件处理"
    ],
    "difficulty": "Medium",
    "title": "开发一个无限下拉加载图片的页面，如何给每个图片绑定 click 事件？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Event Handling",
      "事件处理",
      "Loading"
    ],
    "difficulty": "Easy",
    "title": "window.onload 和 DOMContentLoaded 的区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Performance",
      "性能",
      "Script Loading"
    ],
    "difficulty": "Medium",
    "title": "script 标签放在 head 里，怎么解决加载阻塞的问题"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Basic Concepts",
      "基本概念",
      "Inline vs Block"
    ],
    "difficulty": "Easy",
    "title": "常见的 HTML 标签哪些是 inline 元素，哪些是 block 元素，哪些是 inline-block 元素"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Selectors",
      "选择器"
    ],
    "difficulty": "Easy",
    "title": "常见的 CSS 选择器有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Box Model",
      "盒子模型"
    ],
    "difficulty": "Medium",
    "title": "CSS 盒子模型，尺寸计算"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "Margin Collapse"
    ],
    "difficulty": "Medium",
    "title": "margin 纵向重叠"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Text Styling",
      "文本样式",
      "Inheritance"
    ],
    "difficulty": "Easy",
    "title": "lineHeight 如何继承？"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "Negative Margin"
    ],
    "difficulty": "Medium",
    "title": "margin 负值问题"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "BFC"
    ],
    "difficulty": "Medium",
    "title": "什么是 BFC 如何触发 BFC？"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "Centering"
    ],
    "difficulty": "Medium",
    "title": "使用 CSS 实现居中对齐，有哪几种方式？"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Positioning",
      "定位",
      "Positioning Context"
    ],
    "difficulty": "Medium",
    "title": "什么是 CSS 定位上下文？absolute 和 relative 分别依据谁来定位？"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Visibility",
      "可见性"
    ],
    "difficulty": "Easy",
    "title": "CSS overflow: hidden display：none 和 visibility: hidden 有什么区别"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Units",
      "单位"
    ],
    "difficulty": "Easy",
    "title": "CSS px % em rem vw/vh 的区别"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "UI",
      "Retina"
    ],
    "difficulty": "Medium",
    "title": "如何实现 Retina 屏 1px 像素边框"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "UI",
      "Triangle"
    ],
    "difficulty": "Easy",
    "title": "使用 CSS 画一个三角形"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "UI",
      "Theme"
    ],
    "difficulty": "Medium",
    "title": "如何实现黑白主题变化？"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "Responsive Design"
    ],
    "difficulty": "Medium",
    "title": "如何实现响应式布局？"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Z-index"
    ],
    "difficulty": "Easy",
    "title": "如何理解 z-index ？"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "Flexbox"
    ],
    "difficulty": "Hard",
    "title": "使用 flex 设计一个“四合院”布局"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Tools",
      "工具",
      "Frameworks",
      "预处理器"
    ],
    "difficulty": "Medium",
    "title": "你用过哪些 CSS 相关的技术，如库、框架、预处理语言、后处理语言等"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Easy",
    "title": "TS 优缺点，使用场景"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Easy",
    "title": "TS 基础类型有哪些"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Array",
      "数组",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Easy",
    "title": "数组 Array 和元组 Tuple 的区别是什么"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Easy",
    "title": "枚举 enum 是什么？有什么使用场景？"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "keyof 和 typeof 有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "any void never unknown 有什么区别"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "unknown 和 any 区别"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "TS 访问修饰符 public protected private 有什么作用"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "type 和 interface 共同和区别，如何选择"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "什么是泛型，如何使用它？"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "什么是交叉类型和联合类型"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "是否用过工具类型"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "TS 这些符号 ? ?. ?? ! _ & | # 分别什么意思"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "什么是抽象类 abstract class"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Hard",
    "title": "如何扩展 window 属性，如何定义第三方模块的类型"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Experience",
      "经验"
    ],
    "difficulty": "Medium",
    "title": "是否有过真实的 Typescript 开发经验，讲一下你的使用体验"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "TCP 是如何建立连接的，三次握手，四次挥手"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "HTTP 几个版本的区别"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "HTTP 常见的状态码"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "HTTP 常见 Header"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "URL 包含哪些部分？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "GET 和 POST 请求的区别"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "Ajax Fetch Axios 三者有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "Fetch 和 XMLHTTPRequest 有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "什么是 Restful API ？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "什么是 GraphQL ？"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Hash Table",
      "哈希表"
    ],
    "difficulty": "Easy",
    "title": "1. 两数之和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "String",
      "字符串"
    ],
    "difficulty": "Medium",
    "title": "49. 字母异位词分组"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "128. 最长连续序列"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Two Pointers",
      "双指针"
    ],
    "difficulty": "Easy",
    "title": "283. 移动零"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "11. 盛最多水的容器"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "15. 三数之和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Hard",
    "title": "42. 接雨水"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "String",
      "字符串",
      "Sliding Window",
      "滑动窗口"
    ],
    "difficulty": "Medium",
    "title": "3. 无重复字符的最长子串"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "String",
      "字符串"
    ],
    "difficulty": "Medium",
    "title": "438. 找到字符串中所有字母异位词"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "560. 和为 K 的子数组"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Sliding Window",
      "滑动窗口"
    ],
    "difficulty": "Hard",
    "title": "239. 滑动窗口最大值"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "String",
      "字符串",
      "Sliding Window",
      "滑动窗口"
    ],
    "difficulty": "Hard",
    "title": "76. 最小覆盖子串"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "53. 最大子数组和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "56. 合并区间"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "189. 轮转数组"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "238. 除自身以外数组的乘积"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Hard",
    "title": "41. 缺失的第一个正数"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Matrix",
      "矩阵"
    ],
    "difficulty": "Medium",
    "title": "73. 矩阵置零"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Matrix",
      "矩阵"
    ],
    "difficulty": "Medium",
    "title": "54. 螺旋矩阵"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Matrix",
      "矩阵"
    ],
    "difficulty": "Medium",
    "title": "48. 旋转图像"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Matrix",
      "矩阵"
    ],
    "difficulty": "Medium",
    "title": "240. 搜索二维矩阵 II"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "160. 相交链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "206. 反转链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "234. 回文链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "141. 环形链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Medium",
    "title": "142. 环形链表 II"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "21. 合并两个有序链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Medium",
    "title": "2. 两数相加"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Medium",
    "title": "19. 删除链表的倒数第 N 个结点"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Medium",
    "title": "24. 两两交换链表中的节点"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Hard",
    "title": "25. K 个一组翻转链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Medium",
    "title": "138. 随机链表的复制"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表",
      "Sorting",
      "排序"
    ],
    "difficulty": "Medium",
    "title": "148. 排序链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Hard",
    "title": "23. 合并 K 个升序链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Medium",
    "title": "146. LRU 缓存"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Easy",
    "title": "94. 二叉树的中序遍历"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Easy",
    "title": "104. 二叉树的最大深度"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Easy",
    "title": "226. 翻转二叉树"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Easy",
    "title": "101. 对称二叉树"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Easy",
    "title": "543. 二叉树的直径"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "102. 二叉树的层序遍历"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树",
      "Binary Search Tree",
      "二叉搜索树"
    ],
    "difficulty": "Easy",
    "title": "108. 将有序数组转换为二叉搜索树"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树",
      "Binary Search Tree",
      "二叉搜索树"
    ],
    "difficulty": "Medium",
    "title": "98. 验证二叉搜索树"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树",
      "Binary Search Tree",
      "二叉搜索树"
    ],
    "difficulty": "Medium",
    "title": "230. 二叉搜索树中第 K 小的元素"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "199. 二叉树的右视图"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "114. 二叉树展开为链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "105. 从前序与中序遍历序列构造二叉树"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "437. 路径总和 III"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "236. 二叉树的最近公共祖先"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Hard",
    "title": "124. 二叉树中的最大路径和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Graph",
      "图"
    ],
    "difficulty": "Medium",
    "title": "200. 岛屿数量"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Graph",
      "图"
    ],
    "difficulty": "Medium",
    "title": "994. 腐烂的橘子"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Graph",
      "图"
    ],
    "difficulty": "Medium",
    "title": "207. 课程表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Trie",
      "前缀树"
    ],
    "difficulty": "Medium",
    "title": "208. 实现 Trie (前缀树)"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "46. 全排列"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "78. 子集"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "17. 电话号码的字母组合"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "39. 组合总和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "22. 括号生成"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "79. 单词搜索"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "131. 分割回文串"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Hard",
    "title": "51. N 皇后"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找"
    ],
    "difficulty": "Easy",
    "title": "35. 搜索插入位置"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找",
      "Matrix",
      "矩阵"
    ],
    "difficulty": "Medium",
    "title": "74. 搜索二维矩阵"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找"
    ],
    "difficulty": "Medium",
    "title": "34. 在排序数组中查找元素的第一个和最后一个位置"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找"
    ],
    "difficulty": "Medium",
    "title": "33. 搜索旋转排序数组"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找"
    ],
    "difficulty": "Medium",
    "title": "153. 寻找旋转排序数组中的最小值"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找"
    ],
    "difficulty": "Hard",
    "title": "4. 寻找两个正序数组的中位数"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Stack",
      "栈"
    ],
    "difficulty": "Easy",
    "title": "20. 有效的括号"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Stack",
      "栈"
    ],
    "difficulty": "Medium",
    "title": "155. 最小栈"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Stack",
      "栈",
      "String",
      "字符串"
    ],
    "difficulty": "Medium",
    "title": "394. 字符串解码"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Stack",
      "栈"
    ],
    "difficulty": "Medium",
    "title": "739. 每日温度"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Stack",
      "栈"
    ],
    "difficulty": "Hard",
    "title": "84. 柱状图中最大的矩形"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Heap",
      "堆"
    ],
    "difficulty": "Medium",
    "title": "215. 数组中的第K个最大元素"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Heap",
      "堆",
      "Hash Table",
      "哈希表"
    ],
    "difficulty": "Medium",
    "title": "347. 前 K 个高频元素"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Heap",
      "堆",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Hard",
    "title": "295. 数据流的中位数"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Greedy",
      "贪心算法"
    ],
    "difficulty": "Easy",
    "title": "121. 买卖股票的最佳时机"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Greedy",
      "贪心算法"
    ],
    "difficulty": "Medium",
    "title": "55. 跳跃游戏"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Greedy",
      "贪心算法"
    ],
    "difficulty": "Medium",
    "title": "45. 跳跃游戏 II"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Greedy",
      "贪心算法"
    ],
    "difficulty": "Medium",
    "title": "763. 划分字母区间"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Easy",
    "title": "70. 爬楼梯"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Easy",
    "title": "118. 杨辉三角"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "198. 打家劫舍"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "279. 完全平方数"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "322. 零钱兑换"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "139. 单词拆分"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "300. 最长递增子序列"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "152. 乘积最大子数组"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "416. 分割等和子集"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Hard",
    "title": "32. 最长有效括号"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "62. 不同路径"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "64. 最小路径和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划",
      "String",
      "字符串"
    ],
    "difficulty": "Medium",
    "title": "5. 最长回文子串"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "1143. 最长公共子序列"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "72. 编辑距离"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Bit Manipulation",
      "位运算"
    ],
    "difficulty": "Easy",
    "title": "136. 只出现一次的数字"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Easy",
    "title": "169. 多数元素"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Sorting",
      "排序"
    ],
    "difficulty": "Medium",
    "title": "75. 颜色分类"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "31. 下一个排列"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "287. 寻找重复数"
  },
  {
    "type": "Coding",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "Java两个线程交叉打印"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MQ"
    ],
    "difficulty": "Medium",
    "title": "为什么使用消息队列？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MQ"
    ],
    "difficulty": "Medium",
    "title": "消息队列有什么优点和缺点？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "MQ",
      "Kafka",
      "RocketMQ"
    ],
    "difficulty": "Hard",
    "title": "Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么区别，以及适合哪些场景？"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "2610. 转换二维数组"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ThreadPoolExecutor",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "Java线程池 ThreadPoolExecutor 为什么要使用高位存储runState"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Serialization",
      "序列化"
    ],
    "difficulty": "Medium",
    "title": "Serialize 接口的作用是什么？serialVersionUID 呢？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "简单讲一下线程池"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "线程池的拒绝策略大概有几种?"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "线程池的池化思想还被用在哪里?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Spring",
      "Spring"
    ],
    "difficulty": "Medium",
    "title": "spring最核心的是什么?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Spring",
      "Spring"
    ],
    "difficulty": "Medium",
    "title": "简单讲一下你对IOC的理解?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Spring",
      "Spring"
    ],
    "difficulty": "Medium",
    "title": "spring生成的bean和直接new的对象有什么区别?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Spring",
      "Spring",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Hard",
    "title": "spring的bean是线程安全的吗?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Spring",
      "Spring"
    ],
    "difficulty": "Medium",
    "title": "讲一下springMVC最核心的是什么?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Spring",
      "Spring"
    ],
    "difficulty": "Medium",
    "title": "是怎么解析url的?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Spring",
      "Spring"
    ],
    "difficulty": "Medium",
    "title": "实现springMVC最核心的几个类是什么?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "mysql的在innodb存储引擎下数据是怎么组织的?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "索引和数据是放在一起的吗?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Tree",
      "树"
    ],
    "difficulty": "Medium",
    "title": "讲一下b+树"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Tree",
      "树"
    ],
    "difficulty": "Medium",
    "title": "b+树在非叶子结点不存储数据相比于b树有什么优势?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Algorithms",
      "算法"
    ],
    "difficulty": "Medium",
    "title": "为什么加索引能提升查询速度?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Algorithms",
      "算法"
    ],
    "difficulty": "Hard",
    "title": "b+树o(lg n)是怎么得出来的?底数是多少?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Tree",
      "树"
    ],
    "difficulty": "Hard",
    "title": "b+树的k叉树这个k最大是多少?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "mysql的数据写经历了哪些过程?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "mysql中有哪几种log?简单答一下各自的作用?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "了解mysql的MVCC吗?核心的是什么?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "JVM",
      "JVM"
    ],
    "difficulty": "Medium",
    "title": "jvm的内存结构?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "JVM",
      "JVM",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "哪些是线程私有的?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "JVM",
      "JVM"
    ],
    "difficulty": "Easy",
    "title": "代码文件(.java文件)是放在哪里的?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "JVM",
      "JVM",
      "Algorithms",
      "算法"
    ],
    "difficulty": "Hard",
    "title": "如何理解\"尽量将递归转为迭代\",结合jvm讲一下?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池是什么？为什么使用线程池？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "线程池的原理是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "Java 线程池的参数有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的类型有哪些？分别适用于什么场景？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的拒绝策略有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何监控线程池的状态？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "使用无界队列的线程池会导致内存飙升吗？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何合理配置线程池的大小？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的execute()和submit()方法有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何优雅地关闭线程池？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的创建方式有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "`ThreadPoolExecutor` 的核心参数有哪些，它们的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "线程池是如何管理线程的生命周期的？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的饱和策略有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "什么是线程池的“预热”？如何实现？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何动态调整线程池的参数？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "在使用线程池时，如何避免死锁？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何选择合适的 `BlockingQueue`？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "`Future`接口的作用是什么？如何使用它来获取线程池任务的执行结果？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在使用线程池时，如何处理任务中抛出的异常？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的监控指标有哪些？如何通过 JMX 监控线程池？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "除了 `ThreadPoolExecutor`，还有其他的线程池实现吗？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "`ForkJoinPool` 和 `ThreadPoolExecutor` 有什么区别？分别适用于什么场景？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "什么是 `CompletableFuture`？它和线程池有什么关系？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何使用线程池来执行定时任务？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在 Spring 框架中，如何配置和使用线程池？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的 execute() 和 submit() 方法有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "ThreadPoolExecutor 的核心参数有哪些，它们的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何选择合适的 BlockingQueue？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "Future 接口的作用是什么？如何使用它来获取线程池任务的执行结果？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "ThreadPoolExecutor 中，任务是如何从 workQueue 中被取出的？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "ThreadPoolExecutor 中，addWorker 方法的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "分析 ThreadPoolExecutor 的状态转换过程。"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的 allowCoreThreadTimeOut 参数有什么作用？在什么情况下应该使用它？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的 prestartAllCoreThreads() 方法有什么作用？它和线程池的预热有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "除了 ThreadPoolExecutor，还有其他的线程池实现吗？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "ForkJoinPool 和 ThreadPoolExecutor 有什么区别？分别适用于什么场景？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "什么是 CompletableFuture？它和线程池有什么关系？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "ForkJoinPool 的工作窃取 (Work-Stealing) 算法是如何实现的？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "什么是反应式编程 (Reactive Programming)？它和线程池有什么关系？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "什么是虚拟线程 (Virtual Threads, Project Loom)？它和线程池有什么区别和优势？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "CompletionService 是什么？它解决了什么问题？如何使用它来提高线程池的利用率？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何使用 ExecutorService.invokeAll() 方法来批量执行任务？它和 ExecutorService.submit() 有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "如何使用 CompletableFuture 来构建异步管道？它和传统的线程池有什么优势？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "如何使用 Java 9 引入的 Flow API 来实现响应式编程？它和线程池有什么关系？"
  },
  {
    "type": "Coding",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何设计一个线程池，满足特定的性能指标（例如：吞吐量、延迟）"
  },
  {
    "type": "Coding",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何实现一个自定义的拒绝策略？"
  },
  {
    "type": "Coding",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何实现一个自定义的 ThreadFactory？为什么要自定义 ThreadFactory？"
  },
  {
    "type": "Coding",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "如何在线程池中实现任务的优先级调度？"
  },
  {
    "type": "Coding",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何保证提交到线程池的任务的执行顺序？"
  },
  {
    "type": "Coding",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "如何设计一个可伸缩的线程池？"
  },
  {
    "type": "Coding",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如果线程池中的线程因为异常而终止，如何自动重启线程？"
  },
  {
    "type": "Coding",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何实现一个线程池的优雅降级方案？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何避免死锁？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在什么情况下适合使用 CachedThreadPool？它的缺点是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "如何排查线程池中的线程死锁问题？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何避免线程池中的线程饥饿问题？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如果线程池的任务执行时间不稳定，如何优化线程池的配置？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "在高并发场景下，如何避免线程池成为性能瓶颈？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "你在实际项目中使用线程池遇到过什么问题？你是如何解决的？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何使用 Java Flight Recorder (JFR) 分析线程池的性能问题？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何避免在 Runnable 或 Callable 中抛出未捕获的异常？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何使用 APM (Application Performance Monitoring) 工具来监控线程池的性能？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何根据线程池的监控数据进行调优？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何使用压力测试工具来评估线程池的性能？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在使用线程池时，如何保证线程安全？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "volatile 关键字在线程池中有什么应用？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "AtomicInteger 等原子类在线程池中有什么作用？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何使用 CountDownLatch、CyclicBarrier、Semaphore 等并发工具来协调线程池中的任务？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "Exchanger 在线程池中有什么应用？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何使用 Phaser 来管理线程池中的阶段性任务？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何避免在线程池中使用过多的 synchronized 关键字？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的线程上下文切换是如何发生的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的线程调度算法是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "Java 内存模型 (JMM) 在线程池中扮演什么角色？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Thread Pool",
      "线程池",
      "Design Pattern",
      "设计模式"
    ],
    "difficulty": "Medium",
    "title": "线程池是否体现了某种设计模式？如果是，是什么模式？请描述该模式的意图和如何在线程池中体现。"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在高并发订单场景中，如何使用线程池来优化性能？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在处理大数据任务时，如何使用线程池来并行处理数据？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在处理 I/O 密集型任务时，如何选择合适的线程池配置？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在微服务架构中，如何管理和监控各个服务的线程池？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "请分享一个你曾经遇到的线程池相关的性能问题，你是如何分析和解决的？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "请分析一个开源项目中的线程池使用方式，并指出其优点和缺点。"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "你有什么关于线程池使用的经验或者教训可以分享？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在 Spring 中，如何配置和使用 ThreadPoolTaskExecutor？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "Spring 的 @Async 注解是如何工作的？它和线程池有什么关系？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何在 Spring Boot 应用中监控和管理线程池？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何在 Spring Cloud 应用中使用线程池来实现服务间的异步调用？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 的基本原理是什么？它是如何实现同步的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 中的同步状态（state）有哪些用途？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 的公平锁和非公平锁有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 中的 ConditionObject 是什么？它有什么作用？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 的 acquire 和 release 流程是怎样的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 如何支持共享模式和独占模式？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Data Structures",
      "数据结构",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "描述 AQS 的核心数据结构，以及它们在同步中的作用。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Data Structures",
      "数据结构",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 中的 Node 节点是如何组织的？它们的状态有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "解释 acquireShared 和 releaseShared 方法在共享模式下的工作原理。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 如何避免死锁？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Hard",
    "title": "如果自定义同步器，需要重写 AQS 的哪些方法？请给出具体例子。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 中的 tryAcquire 方法返回不同的值代表什么含义？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 如何处理中断信号？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Hard",
    "title": "AQS 的性能瓶颈可能出现在哪些地方？如何优化？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 在 CountDownLatch、CyclicBarrier 和 Semaphore 中的应用有什么不同？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "解释 AQS 的“模板方法模式”。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 中，如果等待队列过长，会产生什么问题？如何解决？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 的 doAcquireInterruptibly 方法和 acquireQueued 方法有什么区别？分别在什么情况下使用？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 如何保证在并发环境下，只有一个线程能够成功获取锁？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 中的 cancelAcquire 方法的作用是什么？什么情况下会调用它？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "如果一个线程在 AQS 的等待队列中，但是它不想继续等待了，应该如何操作？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 的状态 (state) 除了用于表示锁的持有状态，还可以用于其他用途吗？请举例说明。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "在自定义 AQS 同步器时，如何选择合适的同步模式（独占或共享）？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 的 hasQueuedPredecessors 方法的作用是什么？它在公平锁和非公平锁中的作用有什么不同？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Hard",
    "title": "如何使用 AQS 实现一个自定义的读写锁？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "谈谈你对 AQS 中 \"自旋\" 的理解，以及它对性能的影响。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 的特点是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 是如何实现可重入性的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 的 lock() 和 unlock() 方法应该如何使用？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 提供了哪些方法来尝试获取锁？它们有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 中的 Condition 是如何使用的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 的底层实现是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 的公平锁是如何保证公平性的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 的非公平锁有什么优势？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 中的 Condition 对象是如何与锁关联的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Hard",
    "title": "使用 ReentrantLock 实现一个简单的有界阻塞队列。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 的可重入性是如何影响性能的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "如何使用 ReentrantLock 来避免死锁？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 相比于 synchronized，在调试方面有什么优势？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 如何处理线程优先级反转问题？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Hard",
    "title": "分析 ReentrantLock 在高并发场景下的性能表现。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Hard",
    "title": "如何使用 ReentrantLock 实现一个线程安全的计数器？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Hard",
    "title": "在一个多线程环境中，如何使用 ReentrantLock 保护一个共享资源，避免数据竞争？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Hard",
    "title": "如何使用 ReentrantLock 和 Condition 实现生产者-消费者模式？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Hard",
    "title": "如何使用 ReentrantLock 实现一个可定时的任务调度器？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "在什么情况下，使用 ReentrantLock 的 tryLock 方法比 lock 方法更合适？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "如何通过监控 ReentrantLock 的状态，来诊断并发问题？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "如果在使用 ReentrantLock 时，忘记在 finally 块中释放锁，会发生什么问题？如何避免？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Hard",
    "title": "如何使用 ReentrantLock 实现一个简单的线程池？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "在使用 ReentrantLock 时，如何选择合适的锁的公平性策略？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Hard",
    "title": "如何通过 ReentrantLock 实现一个简单的分布式锁？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Medium",
    "title": "Fork/Join主要用来解决什么样的问题？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Easy",
    "title": "Fork/Join框架是在哪个JDK版本中引入的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Medium",
    "title": "Fork/Join框架主要包含哪三个模块？模块之间的关系是怎么样的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Medium",
    "title": "ForkJoinPool类继承关系？ForkJoinTask抽象类继承关系？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Medium",
    "title": "在实际运用中，我们一般都会继承 RecursiveTask 、RecursiveAction 或 CountedCompleter 来实现我们的业务需求，而不会直接继承 ForkJoinTask 类。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Hard",
    "title": "整个Fork/Join 框架的执行流程/运行机制是怎么样的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Hard",
    "title": "具体阐述Fork/Join的分治思想和work-stealing 实现方式？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Medium",
    "title": "有哪些JDK源码中使用了Fork/Join思想？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Medium",
    "title": "如何使用Executors工具类创建ForkJoinPool？"
  },
  {
    "type": "Coding",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Algorithms",
      "算法",
      "ForkJoinPool"
    ],
    "difficulty": "Medium",
    "title": "写一个例子: 用ForkJoin方式实现1+2+3+...+100000？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Medium",
    "title": "Fork/Join在使用时有哪些注意事项？结合JDK中的斐波那契数列实例具体说明。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "进程间通信和线程间通信的几种方式和区别"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "为什么要有虚拟内存？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "malloc 是如何分配内存的？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "内存满了，会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "在 4GB 物理内存的机器上，申请 8G 内存会怎么样？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "如何避免预读失效和缓存污染的问题？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "什么是预读机制？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "预读失效会带来什么问题？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "如何避免预读失效造成的影响？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "什么是缓存污染？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "缓存污染会带来什么问题？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "怎么避免缓存污染造成的影响？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "深入理解 Linux 虚拟内存管理"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "深入理解 Linux 物理内存管理"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Medium",
    "title": "缓存写策略：写直达（Write Through）与写回（Write Back）的区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "什么是CPU缓存一致性问题？如何保证缓存一致性？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Hard",
    "title": "解释MESI协议及其四种状态（Modified, Exclusive, Shared, Invalidated）。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "Data Representation",
      "数据表示"
    ],
    "difficulty": "Easy",
    "title": "为什么计算机中使用补码来表示负数？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "Data Representation",
      "数据表示"
    ],
    "difficulty": "Easy",
    "title": "十进制小数如何转换为二进制表示？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "Data Representation",
      "数据表示"
    ],
    "difficulty": "Medium",
    "title": "计算机是如何存储浮点数的？请解释IEEE 754标准。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "Data Representation",
      "数据表示"
    ],
    "difficulty": "Medium",
    "title": "为什么在很多编程语言中，0.1 + 0.2 不等于 0.3？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Easy",
    "title": "为什么在CPU和主内存之间需要CPU Cache（高速缓存）？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Easy",
    "title": "什么是缓存行（Cache Line）？它的大小通常是多少？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "什么是CPU缓存伪共享（False Sharing）？如何避免伪共享问题？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "CPU Scheduling",
      "CPU调度"
    ],
    "difficulty": "Medium",
    "title": "Linux内核是如何调度普通任务的？解释一下CFS（完全公平调度器）和vruntime。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "CPU Scheduling",
      "CPU调度"
    ],
    "difficulty": "Easy",
    "title": "在Linux中，如何调整一个正在运行进程的优先级？（nice, renice）"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构"
    ],
    "difficulty": "Easy",
    "title": "请简述冯诺依曼体系结构的主要组成部分。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构"
    ],
    "difficulty": "Easy",
    "title": "32位CPU和64位CPU的主要区别是什么？64位一定比32位快很多吗？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机体系结构"
    ],
    "difficulty": "Medium",
    "title": "32位操作系统能否运行在64位CPU上？64位操作系统能否运行在32位CPU上？为什么？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构"
    ],
    "difficulty": "Medium",
    "title": "描述CPU执行一条指令的基本周期（取指、译码、执行、写回）。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "哪些因素会影响程序在CPU上的执行速度？（指令数、CPI、时钟频率）"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Easy",
    "title": "解释CPU缓存的不同级别（L1, L2, L3）及其特点。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如何编写代码以提高CPU数据缓存的命中率？（例如：数组遍历顺序）"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如何编写代码以提高CPU指令缓存的命中率？（例如：利用分支预测）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机体系结构",
      "Concurrency",
      "并发",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "在多核CPU系统中，CPU亲和性（CPU Affinity）如何帮助提高程序性能？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Easy",
    "title": "什么是中断？它在操作系统中起什么作用？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Medium",
    "title": "硬中断和软中断（Softirq）的主要区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Medium",
    "title": "为什么Linux将中断处理分为上半部（Top Half）和下半部（Bottom Half）？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Interrupts",
      "中断",
      "Troubleshooting",
      "故障排查"
    ],
    "difficulty": "Easy",
    "title": "在Linux系统中，如何查看软中断（Softirq）的统计信息？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Interrupts",
      "中断",
      "Troubleshooting",
      "故障排查",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如果发现系统软中断CPU使用率过高，你会如何诊断和定位问题？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Easy",
    "title": "描述计算机的存储层次结构（寄存器、缓存、内存、硬盘）。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "比较SRAM和DRAM的特点、用途和成本。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Easy",
    "title": "简述不同存储层级（缓存、内存、SSD、HDD）在访问速度和成本上的大致差异。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Easy",
    "title": "虚拟内存的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "Linux 进程的内存布局是怎样的？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "内存分段和内存分页的区别和优缺点是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理",
      "Computer Architecture",
      "计算机体系结构"
    ],
    "difficulty": "Medium",
    "title": "多级页表和 TLB 是如何工作的？它们解决了什么问题？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理",
      "C Programming",
      "C语言"
    ],
    "difficulty": "Medium",
    "title": "malloc 是如何分配内存的？(brk 和 mmap 的区别)"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理",
      "C Programming",
      "C语言"
    ],
    "difficulty": "Medium",
    "title": "free() 函数如何知道要释放多大的内存？free 后内存会立即归还给 OS 吗？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "在 4GB 物理内存的 64 位机器上申请 8G 内存会发生什么？需要考虑哪些因素？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "什么是 Swap 机制？它在什么情况下会被触发？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "系统内存不足时，Linux 会如何回收内存？(kswapd, 直接回收, OOM)"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "文件页和匿名页的回收方式有什么不同？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "什么是 OOM Killer？它是如何选择进程杀死的？如何调整？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Cache",
      "缓存",
      "Algorithms",
      "算法",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Hard",
    "title": "解释 Linux/MySQL 中改进的 LRU 算法如何解决预读失效和缓存污染问题。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Linux",
      "Linux",
      "Performance Tuning",
      "性能调优",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "swappiness, min_free_kbytes, zone_reclaim_mode 这些内核参数的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Thread",
      "线程",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "一个进程最多可以创建多少个线程？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Deadlock",
      "死锁",
      "Thread",
      "线程"
    ],
    "difficulty": "Medium",
    "title": "如何避免死锁？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Deadlock",
      "死锁"
    ],
    "difficulty": "Easy",
    "title": "死锁产生的四个必要条件是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Deadlock",
      "死锁",
      "Debugging",
      "调试"
    ],
    "difficulty": "Hard",
    "title": "如何使用 pstack/gdb 等工具排查死锁问题？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Synchronization",
      "同步",
      "Mutual Exclusion",
      "互斥",
      "Thread",
      "线程"
    ],
    "difficulty": "Medium",
    "title": "多线程冲突与同步互斥机制"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Race Condition",
      "竞争条件"
    ],
    "difficulty": "Easy",
    "title": "什么是竞争条件（Race Condition）？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Critical Section",
      "临界区"
    ],
    "difficulty": "Easy",
    "title": "什么是临界区（Critical Section）？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Synchronization",
      "同步",
      "Mutual Exclusion",
      "互斥"
    ],
    "difficulty": "Medium",
    "title": "同步（Synchronization）与互斥（Mutual Exclusion）的区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Locking",
      "锁",
      "Spinlock",
      "自旋锁"
    ],
    "difficulty": "Medium",
    "title": "锁的实现方式（忙等待锁与无忙等待锁）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Semaphore",
      "信号量",
      "Synchronization",
      "同步",
      "Mutual Exclusion",
      "互斥"
    ],
    "difficulty": "Medium",
    "title": "信号量（Semaphore）及其 P/V 操作如何实现互斥与同步？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Synchronization",
      "同步",
      "Producer-Consumer Problem",
      "生产者消费者问题",
      "Semaphore",
      "信号量"
    ],
    "difficulty": "Medium",
    "title": "生产者消费者问题及其信号量解决方案"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Synchronization",
      "同步",
      "Deadlock",
      "死锁",
      "Dining Philosophers Problem",
      "哲学家就餐问题",
      "Semaphore",
      "信号量"
    ],
    "difficulty": "Hard",
    "title": "哲学家就餐问题及其解决方案（避免死锁）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Synchronization",
      "同步",
      "Readers-Writers Problem",
      "读者写者问题",
      "Semaphore",
      "信号量"
    ],
    "difficulty": "Hard",
    "title": "读者写者问题及其解决方案（读者优先、写者优先、公平）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Locking",
      "锁",
      "Pessimistic Lock",
      "悲观锁",
      "Optimistic Lock",
      "乐观锁",
      "Database",
      "数据库"
    ],
    "difficulty": "Medium",
    "title": "什么是悲观锁和乐观锁？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Locking",
      "锁",
      "Mutex",
      "互斥锁",
      "Spinlock",
      "自旋锁"
    ],
    "difficulty": "Medium",
    "title": "互斥锁（Mutex）和自旋锁（Spinlock）的区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Locking",
      "锁",
      "Read-Write Lock",
      "读写锁"
    ],
    "difficulty": "Medium",
    "title": "什么是读写锁？读者优先、写者优先、公平读写锁的区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Atomic Operation",
      "原子操作",
      "CAS",
      "比较并交换"
    ],
    "difficulty": "Medium",
    "title": "CAS（Compare-And-Swap）原子操作的原理是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程"
    ],
    "difficulty": "Easy",
    "title": "什么是进程？进程和程序的区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Parallelism",
      "并行"
    ],
    "difficulty": "Easy",
    "title": "并发（Concurrency）和并行（Parallelism）的区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Process State",
      "进程状态"
    ],
    "difficulty": "Easy",
    "title": "进程有哪些状态？（运行、就绪、阻塞等）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "PCB",
      "进程控制块"
    ],
    "difficulty": "Medium",
    "title": "什么是进程控制块（PCB）？它包含哪些信息？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "PCB",
      "进程控制块"
    ],
    "difficulty": "Medium",
    "title": "PCB 是如何组织的？（例如，状态队列链表）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Process Management",
      "进程管理"
    ],
    "difficulty": "Medium",
    "title": "描述进程的创建、终止、阻塞和唤醒过程"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Context Switching",
      "上下文切换"
    ],
    "difficulty": "Medium",
    "title": "什么是上下文切换？进程上下文切换会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Thread",
      "线程",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Easy",
    "title": "为什么使用线程？线程的优缺点是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Thread",
      "线程",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Easy",
    "title": "进程和线程的主要区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Thread",
      "线程",
      "Context Switching",
      "上下文切换"
    ],
    "difficulty": "Medium",
    "title": "线程上下文切换会发生什么？与进程上下文切换有何不同？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Thread",
      "线程",
      "User Thread",
      "用户线程",
      "Kernel Thread",
      "内核线程",
      "LWP",
      "轻量级进程"
    ],
    "difficulty": "Hard",
    "title": "描述不同的线程实现模型（用户线程、内核线程、轻量级进程 LWP）及其优缺点"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Scheduling",
      "调度",
      "Process",
      "进程",
      "Thread",
      "线程"
    ],
    "difficulty": "Medium",
    "title": "什么是进程/线程调度？调度发生在哪些时机？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Scheduling",
      "调度",
      "Scheduling Algorithm",
      "调度算法"
    ],
    "difficulty": "Medium",
    "title": "调度算法的设计原则有哪些？（CPU利用率、吞吐量、周转时间、等待时间、响应时间）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Scheduling",
      "调度",
      "Scheduling Algorithm",
      "调度算法"
    ],
    "difficulty": "Medium",
    "title": "描述常见的调度算法（FCFS, SJF, HRRN, RR, HPF, MFQ）及其特点"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Inter-Process Communication",
      "进程间通信",
      "IPC"
    ],
    "difficulty": "Medium",
    "title": "进程间有哪些通信方式？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Inter-Process Communication",
      "进程间通信",
      "IPC",
      "Pipe",
      "管道"
    ],
    "difficulty": "Medium",
    "title": "解释管道（匿名管道与命名管道/FIFO）通信机制"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Inter-Process Communication",
      "进程间通信",
      "IPC",
      "Message Queue",
      "消息队列"
    ],
    "difficulty": "Medium",
    "title": "解释消息队列（Message Queue）通信机制"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Inter-Process Communication",
      "进程间通信",
      "IPC",
      "Shared Memory",
      "共享内存"
    ],
    "difficulty": "Medium",
    "title": "解释共享内存（Shared Memory）通信机制"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Inter-Process Communication",
      "进程间通信",
      "IPC",
      "Semaphore",
      "信号量",
      "Synchronization",
      "同步",
      "Mutual Exclusion",
      "互斥"
    ],
    "difficulty": "Medium",
    "title": "解释信号量（Semaphore）在进程间通信中的作用（互斥与同步）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Inter-Process Communication",
      "进程间通信",
      "IPC",
      "Signal",
      "信号"
    ],
    "difficulty": "Medium",
    "title": "解释信号（Signal）作为异步通信机制"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Inter-Process Communication",
      "进程间通信",
      "IPC",
      "Networking",
      "网络",
      "Socket",
      "套接字"
    ],
    "difficulty": "Medium",
    "title": "解释套接字（Socket）通信（包括跨网络和本地）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Thread",
      "线程",
      "Error Handling",
      "错误处理",
      "JVM",
      "Java虚拟机"
    ],
    "difficulty": "Medium",
    "title": "线程崩溃了，进程也会崩溃吗？（区分 C/C++ 与 Java）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Thread",
      "线程",
      "Memory Management",
      "内存管理",
      "C++",
      "C++"
    ],
    "difficulty": "Medium",
    "title": "为什么在 C/C++ 中线程崩溃（如非法内存访问）通常会导致进程崩溃？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Signal",
      "信号"
    ],
    "difficulty": "Medium",
    "title": "信号（Signal）机制在进程终止中是如何工作的？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Thread",
      "线程",
      "JVM",
      "Java虚拟机",
      "Error Handling",
      "错误处理",
      "Signal",
      "信号"
    ],
    "difficulty": "Hard",
    "title": "为什么在 Java 中线程崩溃（如 StackOverflowError 或 NPE）不会导致 JVM 进程崩溃？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process Scheduling",
      "进程调度"
    ],
    "difficulty": "Medium",
    "title": "比较不同的进程调度算法（如 FCFS, SJF, RR, 优先级, MLFQ）的优缺点。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process Scheduling",
      "进程调度"
    ],
    "difficulty": "Easy",
    "title": "什么是抢占式调度和非抢占式调度？它们有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "比较不同的页面置换算法（如 OPT, FIFO, LRU, Clock, LFU）的原理和优缺点。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "解释缺页中断（Page Fault）的处理过程。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Medium",
    "title": "比较不同的磁盘调度算法（如 FCFS, SSTF, SCAN, C-SCAN, LOOK, C-LOOK）的目标和特性。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "File System",
      "文件系统"
    ],
    "difficulty": "Medium",
    "title": "解释文件系统的基本组成：索引节点（inode）和目录项（dentry）的作用和关系。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "File System",
      "文件系统"
    ],
    "difficulty": "Easy",
    "title": "什么是虚拟文件系统（VFS）？它的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "File System",
      "文件系统"
    ],
    "difficulty": "Medium",
    "title": "比较文件的不同存储方式（连续、链表、索引）的优缺点。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "File System",
      "文件系统"
    ],
    "difficulty": "Easy",
    "title": "硬链接（Hard Link）和软链接（Symbolic Link）有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Medium",
    "title": "解释缓冲 I/O 与非缓冲 I/O，直接 I/O 与非直接 I/O 的区别。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Medium",
    "title": "解释阻塞 I/O、非阻塞 I/O、同步 I/O、异步 I/O 的区别和联系。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "什么是 Linux 的 Page Cache？它的作用和优缺点是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Easy",
    "title": "Page Cache 和 Buffer Cache 有什么区别和联系？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "Page Cache 如何保证数据一致性？（Write Through vs Write Back）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Medium",
    "title": "解释 DMA（直接内存访问）的工作原理及其解决了什么问题。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Easy",
    "title": "设备驱动程序的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Medium",
    "title": "键盘敲入一个字母时，操作系统内部发生了什么？（中断处理过程）"
  },
  {
    "type": "Question",
    "category": [
      "System Design",
      "系统设计",
      "Algorithms",
      "算法",
      "Hash Table",
      "哈希表"
    ],
    "difficulty": "Medium",
    "title": "什么是一致性哈希？它解决了什么问题？"
  },
  {
    "type": "Question",
    "category": [
      "System Design",
      "系统设计",
      "Algorithms",
      "算法",
      "Hash Table",
      "哈希表"
    ],
    "difficulty": "Medium",
    "title": "一致性哈希中的虚拟节点是如何解决数据倾斜问题的？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Hard",
    "title": "解释 Reactor 模式及其不同的实现方式（单 Reactor 单线程/多线程，多 Reactor 多线程）。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Hard",
    "title": "Reactor 模式和 Proactor 模式有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "什么是 I/O 多路复用？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Hard",
    "title": "比较 select、poll、epoll 的实现原理和优缺点。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "epoll 的水平触发（LT）和边缘触发（ET）有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Medium",
    "title": "什么是零拷贝（Zero-copy）？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Hard",
    "title": "解释实现零拷贝的几种方式（mmap+write, sendfile）及其原理。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Medium",
    "title": "零拷贝和 PageCache 的关系是什么？传输大文件时为什么不建议用零拷贝？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络"
    ],
    "difficulty": "Easy",
    "title": "衡量网络性能的主要指标有哪些？（带宽、延时、吞吐率、PPS）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络",
      "Linux"
    ],
    "difficulty": "Easy",
    "title": "如何使用 Linux 命令（如 ifconfig/ip, netstat/ss, sar, ping, ethtool）查看网络配置和性能指标？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络",
      "Linux"
    ],
    "difficulty": "Medium",
    "title": "netstat/ss 命令输出中 Recv-Q 和 Send-Q 在不同 socket 状态下分别代表什么？"
  },
  {
    "type": "Question",
    "category": [
      "Linux",
      "Linux",
      "Data Analysis",
      "数据分析"
    ],
    "difficulty": "Medium",
    "title": "如何使用 Linux Shell 命令（awk, sort, uniq, wc）从 Nginx 日志中分析 PV 和 UV？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Medium",
    "title": "CPU Cache 的数据写入方式有哪些？（写直达 vs 写回）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "什么是缓存一致性问题？如何解决？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Hard",
    "title": "解释 MESI 协议。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Hard",
    "title": "MESI 协议的四种状态是什么？它们之间如何转换？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "什么是总线嗅探？它在缓存一致性中扮演什么角色？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理",
      "Data Representation",
      "数据表示"
    ],
    "difficulty": "Easy",
    "title": "为什么负数要用补码表示？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理",
      "Data Representation",
      "数据表示"
    ],
    "difficulty": "Easy",
    "title": "十进制小数如何转换为二进制？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理",
      "Data Representation",
      "数据表示",
      "Floating Point",
      "浮点数"
    ],
    "difficulty": "Medium",
    "title": "计算机是如何存储小数的？（IEEE 754 浮点数标准）"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理",
      "Data Representation",
      "数据表示",
      "Floating Point",
      "浮点数"
    ],
    "difficulty": "Medium",
    "title": "为什么 0.1 + 0.2 不等于 0.3？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理",
      "Data Representation",
      "数据表示",
      "Floating Point",
      "浮点数"
    ],
    "difficulty": "Medium",
    "title": "单精度和双精度浮点数有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Easy",
    "title": "CPU 缓存的层次结构是怎样的？为什么需要多级缓存？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Easy",
    "title": "什么是 CPU Cache Line？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Hard",
    "title": "什么是伪共享（False Sharing）？如何避免？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "CPU Scheduling",
      "CPU调度"
    ],
    "difficulty": "Medium",
    "title": "Linux 中的任务调度策略有哪些？（实时任务 vs 普通任务）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "CPU Scheduling",
      "CPU调度"
    ],
    "difficulty": "Medium",
    "title": "解释 CFS（完全公平调度）算法。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "CPU Scheduling",
      "CPU调度"
    ],
    "difficulty": "Medium",
    "title": "什么是 vruntime？它在 CFS 中如何工作？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "CPU Scheduling",
      "CPU调度"
    ],
    "difficulty": "Easy",
    "title": "如何调整 Linux 任务的优先级？（nice 值）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理"
    ],
    "difficulty": "Medium",
    "title": "CPU 是如何执行程序的？（指令周期）"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理"
    ],
    "difficulty": "Easy",
    "title": "解释冯诺依曼模型的基本组成部分。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理"
    ],
    "difficulty": "Medium",
    "title": "CPU 中的寄存器有哪些主要类型及其作用？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理"
    ],
    "difficulty": "Easy",
    "title": "32 位和 64 位 CPU 的主要区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理"
    ],
    "difficulty": "Easy",
    "title": "64 位 CPU 的计算性能一定比 32 位 CPU 高很多吗？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理"
    ],
    "difficulty": "Medium",
    "title": "解释指令流水线的基本阶段。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如何衡量和提高程序的 CPU 执行速度？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Easy",
    "title": "为什么需要 CPU Cache？它比内存快多少？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Medium",
    "title": "CPU Cache 的数据结构是怎样的？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Medium",
    "title": "解释直接映射缓存（Direct Mapped Cache）的工作原理。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如何编写能提高 CPU 数据缓存命中率的代码？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如何编写能提高 CPU 指令缓存命中率的代码？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "什么是分支预测？它如何影响性能？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "在多核 CPU 上，如何提高缓存命中率？（线程绑定）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Easy",
    "title": "什么是中断？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Easy",
    "title": "为什么中断处理程序需要短而快？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Medium",
    "title": "什么是软中断？它与硬中断有何区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Medium",
    "title": "Linux 为什么要将中断处理分为上半部和下半部？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Medium",
    "title": "Linux 中常见的软中断类型有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Linux",
      "Linux",
      "Troubleshooting",
      "故障排查",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Medium",
    "title": "如何查看和分析 Linux 系统中的软中断情况？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Linux",
      "Linux",
      "Troubleshooting",
      "故障排查",
      "Performance Optimization",
      "性能优化",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Hard",
    "title": "如何定位软中断 CPU 使用率过高的问题？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Easy",
    "title": "描述计算机的存储器层次结构。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Easy",
    "title": "不同层级的存储器在速度、容量、成本上有何差异？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "SRAM 和 DRAM 有什么区别？它们分别用于什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Medium",
    "title": "CPU 访问数据的流程是怎样的（考虑缓存）？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理",
      "Storage",
      "存储"
    ],
    "difficulty": "Easy",
    "title": "机械硬盘、固态硬盘、内存的速度大约相差多少倍？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Kernel",
      "内核"
    ],
    "difficulty": "Easy",
    "title": "内核在操作系统中扮演什么角色？提供哪些基本能力？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Kernel",
      "内核"
    ],
    "difficulty": "Easy",
    "title": "什么是用户态和内核态？为什么需要区分？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Kernel",
      "内核",
      "System Call",
      "系统调用"
    ],
    "difficulty": "Easy",
    "title": "应用程序如何从用户态切换到内核态？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Linux",
      "Linux",
      "Kernel",
      "内核"
    ],
    "difficulty": "Medium",
    "title": "Linux 内核的设计理念有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Kernel",
      "内核"
    ],
    "difficulty": "Medium",
    "title": "宏内核、微内核、混合内核各有什么特点和优缺点？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Linux",
      "Linux",
      "Windows",
      "Windows",
      "Kernel",
      "内核"
    ],
    "difficulty": "Medium",
    "title": "Linux 和 Windows 内核的主要区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Linux",
      "Linux",
      "Windows",
      "Windows",
      "File Format",
      "文件格式"
    ],
    "difficulty": "Medium",
    "title": "Linux 和 Windows 的可执行文件格式分别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库"
    ],
    "difficulty": "Medium",
    "title": "分库分表怎么分"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库"
    ],
    "difficulty": "Medium",
    "title": "SharingSphere怎么查数据的总量"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread",
      "线程"
    ],
    "difficulty": "Medium",
    "title": "为什么要用ThreadLocal，ThreadLocal的原理"
  },
  {
    "type": "Question",
    "category": [
      "Algorithms",
      "算法"
    ],
    "difficulty": "Medium",
    "title": "布隆过滤器原理和特点"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池处理任务的流程"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "面对一个有很多任务的场景，依据什么原则去设计线程池的线程数"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库"
    ],
    "difficulty": "Medium",
    "title": "ACID特性分别怎么实现"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "Tree",
      "树"
    ],
    "difficulty": "Medium",
    "title": "为什么要用B+树"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库"
    ],
    "difficulty": "Medium",
    "title": "LIMIT分页查询为什么后面页面的查询会很慢"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库"
    ],
    "difficulty": "Medium",
    "title": "索引失效有哪些场景"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "两个new Integer（100）是否=="
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Spring",
      "Spring"
    ],
    "difficulty": "Medium",
    "title": "用Spring的时候怎么避免循环依赖"
  },
  {
    "type": "Question",
    "category": [
      "Java"
    ],
    "difficulty": "Medium",
    "title": "类型擦除问题，ArrayList<Int>可以存入一个String吗？"
  },
  {
    "type": "Question",
    "category": [
      "Java"
    ],
    "difficulty": "Medium",
    "title": "java序列化生成的uuid有什么用？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "java有哪些锁？讲讲AQS"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "synchronizied锁的原理"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Hard",
    "title": "CAS操作怎么避免ABA问题"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "volatile关键字有什么用？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "String",
      "字符串"
    ],
    "difficulty": "Medium",
    "title": "redis的String结构和java的String有什么不同"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Medium",
    "title": "redis的ZSET了解吗？底层是什么结构"
  },
  {
    "type": "Question",
    "category": [
      "Redis"
    ],
    "difficulty": "Medium",
    "title": "redis为什么这么快，为什么不使用多线程？"
  },
  {
    "type": "Question",
    "category": [
      "Redis"
    ],
    "difficulty": "Medium",
    "title": "了解Redis Cluster吗？多加几个实例数据要怎么迁移?"
  },
  {
    "type": "Question",
    "category": [
      "Redis"
    ],
    "difficulty": "Medium",
    "title": "redis某个key过期了，删除策略有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Database",
      "数据库"
    ],
    "difficulty": "Easy",
    "title": "什么是 Redis？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Memcached",
      "Database",
      "数据库"
    ],
    "difficulty": "Medium",
    "title": "Redis 和 Memcached 有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "MySQL",
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "Performance",
      "性能"
    ],
    "difficulty": "Medium",
    "title": "为什么用 Redis 作为 MySQL 的缓存？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Medium",
    "title": "Redis 有哪些数据类型及其应用场景？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Data Structures",
      "数据结构",
      "Internal Implementation",
      "内部实现"
    ],
    "difficulty": "Hard",
    "title": "Redis 常见数据类型的底层实现是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Concurrency",
      "并发",
      "Threading Model",
      "线程模型"
    ],
    "difficulty": "Medium",
    "title": "Redis 是单线程吗？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Concurrency",
      "并发",
      "Threading Model",
      "线程模型",
      "Networking",
      "网络",
      "I/O Multiplexing",
      "IO多路复用"
    ],
    "difficulty": "Medium",
    "title": "Redis 的单线程模型是如何工作的？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Performance",
      "性能",
      "Threading Model",
      "线程模型",
      "I/O Multiplexing",
      "IO多路复用"
    ],
    "difficulty": "Medium",
    "title": "为什么单线程的 Redis 性能还这么高？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Threading Model",
      "线程模型",
      "Design Philosophy",
      "设计哲学"
    ],
    "difficulty": "Medium",
    "title": "Redis 6.0 之前为什么采用单线程模型？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Threading Model",
      "线程模型",
      "Performance",
      "性能",
      "Networking",
      "网络"
    ],
    "difficulty": "Medium",
    "title": "Redis 6.0 为什么引入了多线程 I/O？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Persistence",
      "持久化",
      "AOF",
      "RDB"
    ],
    "difficulty": "Easy",
    "title": "Redis 如何保证数据不丢失（持久化机制）？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Persistence",
      "持久化",
      "AOF"
    ],
    "difficulty": "Medium",
    "title": "AOF 日志的实现原理是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Persistence",
      "持久化",
      "AOF",
      "Configuration",
      "配置"
    ],
    "difficulty": "Medium",
    "title": "AOF 有哪几种写回策略？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Persistence",
      "持久化",
      "AOF",
      "AOF Rewrite",
      "AOF重写"
    ],
    "difficulty": "Medium",
    "title": "AOF 文件过大时会发生什么？（AOF 重写机制）"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Persistence",
      "持久化",
      "AOF",
      "AOF Rewrite",
      "AOF重写",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Hard",
    "title": "AOF 重写过程是怎样的？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Persistence",
      "持久化",
      "RDB",
      "Snapshot",
      "快照"
    ],
    "difficulty": "Medium",
    "title": "RDB 快照的实现原理是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Persistence",
      "持久化",
      "RDB",
      "Snapshot",
      "快照",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "RDB 生成快照时会阻塞主线程吗？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Persistence",
      "持久化",
      "RDB",
      "Snapshot",
      "快照",
      "Concurrency",
      "并发",
      "COW",
      "写时复制"
    ],
    "difficulty": "Medium",
    "title": "生成 RDB 快照期间，数据可以修改吗？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Persistence",
      "持久化",
      "RDB",
      "AOF",
      "Hybrid Persistence",
      "混合持久化"
    ],
    "difficulty": "Medium",
    "title": "为什么 Redis 4.0 引入了混合持久化？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "High Availability",
      "高可用",
      "Replication",
      "主从复制",
      "Sentinel",
      "哨兵",
      "Cluster",
      "集群"
    ],
    "difficulty": "Medium",
    "title": "Redis 如何实现服务高可用？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "High Availability",
      "高可用",
      "Cluster",
      "集群",
      "Replication",
      "主从复制",
      "Sentinel",
      "哨兵",
      "Consistency",
      "一致性",
      "Split Brain",
      "脑裂"
    ],
    "difficulty": "Hard",
    "title": "如何防止 Redis 集群脑裂导致数据丢失？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Expiration",
      "过期策略",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "Redis 的 key 过期删除策略是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Expiration",
      "过期策略",
      "Persistence",
      "持久化",
      "RDB",
      "AOF"
    ],
    "difficulty": "Medium",
    "title": "Redis 持久化时如何处理过期 key？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Expiration",
      "过期策略",
      "Replication",
      "主从复制",
      "High Availability",
      "高可用"
    ],
    "difficulty": "Medium",
    "title": "Redis 主从模式下如何处理过期 key？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Memory Management",
      "内存管理",
      "Eviction",
      "内存淘汰"
    ],
    "difficulty": "Easy",
    "title": "Redis 内存满了会怎么样？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Memory Management",
      "内存管理",
      "Eviction",
      "内存淘汰",
      "LRU",
      "LFU"
    ],
    "difficulty": "Medium",
    "title": "Redis 有哪些内存淘汰策略？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Memory Management",
      "内存管理",
      "Eviction",
      "内存淘汰",
      "LRU",
      "LFU",
      "Algorithms",
      "算法"
    ],
    "difficulty": "Medium",
    "title": "LRU 和 LFU 内存淘汰算法有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Memory Management",
      "内存管理",
      "Eviction",
      "内存淘汰",
      "LRU",
      "Algorithms",
      "算法",
      "Internal Implementation",
      "内部实现"
    ],
    "difficulty": "Medium",
    "title": "Redis 如何实现 LRU 算法？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Memory Management",
      "内存管理",
      "Eviction",
      "内存淘汰",
      "LFU",
      "Algorithms",
      "算法",
      "Internal Implementation",
      "内部实现"
    ],
    "difficulty": "Hard",
    "title": "Redis 如何实现 LFU 算法？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "System Design",
      "系统设计",
      "High Availability",
      "高可用",
      "Cache Problems",
      "缓存问题"
    ],
    "difficulty": "Medium",
    "title": "如何避免缓存雪崩、缓存击穿、缓存穿透？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "System Design",
      "系统设计",
      "Cache Strategy",
      "缓存策略",
      "Hot Data",
      "热点数据"
    ],
    "difficulty": "Medium",
    "title": "如何设计动态缓存热点数据的策略？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "System Design",
      "系统设计",
      "Cache Strategy",
      "缓存策略",
      "Consistency",
      "一致性"
    ],
    "difficulty": "Medium",
    "title": "常见的缓存更新策略有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Database",
      "数据库",
      "MySQL",
      "Consistency",
      "一致性",
      "System Design",
      "系统设计",
      "Cache Strategy",
      "缓存策略",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Hard",
    "title": "如何保证数据库和缓存的数据一致性？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Database",
      "数据库",
      "Consistency",
      "一致性",
      "System Design",
      "系统设计",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "更新数据时，应先更新数据库还是先更新缓存？为什么？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Database",
      "数据库",
      "Consistency",
      "一致性",
      "System Design",
      "系统设计",
      "Cache Strategy",
      "缓存策略"
    ],
    "difficulty": "Medium",
    "title": "缓存更新策略：直接更新缓存 V.S. 删除缓存（旁路缓存），各有什么优劣？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Database",
      "数据库",
      "Consistency",
      "一致性",
      "System Design",
      "系统设计",
      "Cache Strategy",
      "缓存策略",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "旁路缓存策略：先删除缓存再更新数据库可能导致什么问题？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Database",
      "数据库",
      "Consistency",
      "一致性",
      "System Design",
      "系统设计",
      "Cache Strategy",
      "缓存策略",
      "Concurrency",
      "并发",
      "Reliability",
      "可靠性"
    ],
    "difficulty": "Hard",
    "title": "旁路缓存策略：先更新数据库再删除缓存可能导致什么问题？如何保证两个操作都成功？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Database",
      "数据库",
      "Consistency",
      "一致性",
      "System Design",
      "系统设计",
      "Cache Strategy",
      "缓存策略"
    ],
    "difficulty": "Medium",
    "title": "什么是延迟双删策略？它有什么缺点？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Database",
      "数据库",
      "Consistency",
      "一致性",
      "System Design",
      "系统设计",
      "Cache Strategy",
      "缓存策略",
      "Message Queue",
      "消息队列",
      "Binlog",
      "Canal"
    ],
    "difficulty": "Hard",
    "title": "如何通过消息队列或订阅 Binlog 来保证缓存与数据库一致性？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Data Structures",
      "数据结构",
      "ZSet",
      "有序集合",
      "Message Queue",
      "消息队列",
      "Use Case",
      "应用场景"
    ],
    "difficulty": "Medium",
    "title": "如何用 Redis 实现延迟队列？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Performance",
      "性能",
      "Operations",
      "运维",
      "Big Key",
      "大Key"
    ],
    "difficulty": "Medium",
    "title": "什么是 Redis 大 Key？如何发现和处理？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Performance",
      "性能",
      "Client",
      "客户端",
      "Pipeline",
      "管道"
    ],
    "difficulty": "Medium",
    "title": "Redis Pipeline（管道）的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Transaction",
      "事务",
      "Atomicity",
      "原子性"
    ],
    "difficulty": "Medium",
    "title": "Redis 事务支持回滚吗？原子性如何保证？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Distributed Lock",
      "分布式锁",
      "Concurrency",
      "并发",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Medium",
    "title": "如何用 Redis 实现分布式锁？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Distributed Lock",
      "分布式锁",
      "Concurrency",
      "并发",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Medium",
    "title": "基于 Redis 实现分布式锁有哪些优缺点？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "缓存",
      "Distributed Lock",
      "分布式锁",
      "Concurrency",
      "并发",
      "System Design",
      "系统设计",
      "High Availability",
      "高可用",
      "Cluster",
      "集群",
      "Redlock"
    ],
    "difficulty": "Hard",
    "title": "Redis 集群环境下如何保证分布式锁的可靠性（Redlock）？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Cache",
      "缓存"
    ],
    "difficulty": "Medium",
    "title": "什么是 Redis 缓存雪崩、击穿、穿透？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Cache",
      "缓存"
    ],
    "difficulty": "Medium",
    "title": "缓存雪崩的原因及解决方案？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Cache",
      "缓存"
    ],
    "difficulty": "Medium",
    "title": "缓存击穿的原因及解决方案？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Cache",
      "缓存"
    ],
    "difficulty": "Medium",
    "title": "缓存穿透的原因及解决方案？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Structures",
      "数据结构",
      "Bloom Filter",
      "布隆过滤器"
    ],
    "difficulty": "Medium",
    "title": "布隆过滤器的工作原理是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Replication",
      "主从复制",
      "High Availability",
      "高可用"
    ],
    "difficulty": "Medium",
    "title": "Redis 主从复制是怎么实现的？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Replication",
      "主从复制"
    ],
    "difficulty": "Easy",
    "title": "Redis 主从节点是长连接还是短链接？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Cluster",
      "集群",
      "High Availability",
      "高可用"
    ],
    "difficulty": "Easy",
    "title": "怎么判断 Redis 某个节点是否正常工作？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Replication",
      "主从复制",
      "Expiration",
      "过期策略"
    ],
    "difficulty": "Medium",
    "title": "主从复制架构中，过期 key 如何处理？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Replication",
      "主从复制"
    ],
    "difficulty": "Easy",
    "title": "Redis 是同步复制还是异步复制？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Replication",
      "主从复制"
    ],
    "difficulty": "Medium",
    "title": "主从复制中两个 Buffer(replication buffer、repl backlog buffer) 有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Replication",
      "主从复制",
      "Consistency",
      "一致性"
    ],
    "difficulty": "Medium",
    "title": "如何应对 Redis 主从数据不一致？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Replication",
      "主从复制",
      "High Availability",
      "高可用",
      "Failover",
      "故障转移"
    ],
    "difficulty": "Hard",
    "title": "Redis 主从切换如何减少数据丢失？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Replication",
      "主从复制",
      "High Availability",
      "高可用",
      "Failover",
      "故障转移",
      "Sentinel",
      "哨兵"
    ],
    "difficulty": "Medium",
    "title": "Redis 主从如何做到故障自动切换？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Sentinel",
      "哨兵",
      "High Availability",
      "高可用"
    ],
    "difficulty": "Easy",
    "title": "为什么要有 Redis 哨兵机制？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Sentinel",
      "哨兵",
      "High Availability",
      "高可用"
    ],
    "difficulty": "Medium",
    "title": "Redis 哨兵机制是如何工作的？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Sentinel",
      "哨兵",
      "High Availability",
      "高可用",
      "Failure Detection",
      "故障检测"
    ],
    "difficulty": "Medium",
    "title": "Redis 哨兵如何判断主节点真的故障了？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Sentinel",
      "哨兵",
      "High Availability",
      "高可用",
      "Failover",
      "故障转移",
      "Leader Election",
      "领导者选举"
    ],
    "difficulty": "Medium",
    "title": "由哪个哨兵进行主从故障转移？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Sentinel",
      "哨兵",
      "High Availability",
      "高可用",
      "Quorum",
      "法定人数"
    ],
    "difficulty": "Medium",
    "title": "为什么哨兵节点至少要有 3 个？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Sentinel",
      "哨兵",
      "High Availability",
      "高可用",
      "Failover",
      "故障转移"
    ],
    "difficulty": "Hard",
    "title": "Redis 主从故障转移的过程是怎样的？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Sentinel",
      "哨兵",
      "High Availability",
      "高可用",
      "Discovery",
      "服务发现"
    ],
    "difficulty": "Medium",
    "title": "Redis 哨兵集群是如何组成的？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Types",
      "数据类型",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Easy",
    "title": "Redis 常见数据类型有哪些？各自的应用场景是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Types",
      "数据类型",
      "String",
      "字符串",
      "SDS"
    ],
    "difficulty": "Medium",
    "title": "Redis String 类型的底层实现和应用场景？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Types",
      "数据类型",
      "List",
      "列表",
      "Message Queue",
      "消息队列"
    ],
    "difficulty": "Medium",
    "title": "Redis List 类型的底层实现和应用场景？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Types",
      "数据类型",
      "Hash",
      "哈希"
    ],
    "difficulty": "Medium",
    "title": "Redis Hash 类型的底层实现和应用场景？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Types",
      "数据类型",
      "Set",
      "集合"
    ],
    "difficulty": "Medium",
    "title": "Redis Set 类型的底层实现和应用场景？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Types",
      "数据类型",
      "Zset",
      "有序集合",
      "Sorted Set"
    ],
    "difficulty": "Medium",
    "title": "Redis Zset 类型的底层实现和应用场景？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Types",
      "数据类型",
      "BitMap",
      "位图"
    ],
    "difficulty": "Medium",
    "title": "Redis BitMap 类型的底层实现和应用场景？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Types",
      "数据类型",
      "HyperLogLog"
    ],
    "difficulty": "Medium",
    "title": "Redis HyperLogLog 类型的底层实现和应用场景？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Types",
      "数据类型",
      "GEO"
    ],
    "difficulty": "Medium",
    "title": "Redis GEO 类型的底层实现和应用场景？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Types",
      "数据类型",
      "Stream",
      "流",
      "Message Queue",
      "消息队列"
    ],
    "difficulty": "Hard",
    "title": "Redis Stream 类型的底层实现和应用场景？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Types",
      "数据类型",
      "List",
      "列表",
      "Stream",
      "流",
      "Message Queue",
      "消息队列"
    ],
    "difficulty": "Medium",
    "title": "Redis List 和 Stream 作为消息队列的区别？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Stream",
      "流",
      "Message Queue",
      "消息队列",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Hard",
    "title": "Redis Stream 与专业消息队列（如 Kafka）的差距？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Pub/Sub",
      "发布/订阅",
      "Message Queue",
      "消息队列"
    ],
    "difficulty": "Medium",
    "title": "Redis 发布/订阅机制为什么不适合做消息队列？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Performance",
      "性能",
      "Data Structures",
      "数据结构",
      "Architecture",
      "架构"
    ],
    "difficulty": "Medium",
    "title": "Redis 为什么快？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Types",
      "数据类型",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Medium",
    "title": "Redis 数据类型和底层数据结构的关系？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Structures",
      "数据结构",
      "String",
      "字符串",
      "SDS"
    ],
    "difficulty": "Medium",
    "title": "什么是 SDS（简单动态字符串）？相比 C 字符串有什么优点？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Structures",
      "数据结构",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "Redis 链表的实现是怎样的？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Structures",
      "数据结构",
      "Ziplist",
      "压缩列表"
    ],
    "difficulty": "Medium",
    "title": "什么是压缩列表（ziplist）？有什么优缺点？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Structures",
      "数据结构",
      "Ziplist",
      "压缩列表",
      "Quicklist",
      "Listpack"
    ],
    "difficulty": "Hard",
    "title": "压缩列表的连锁更新问题是什么？如何解决？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Structures",
      "数据结构",
      "Hash Table",
      "哈希表"
    ],
    "difficulty": "Medium",
    "title": "Redis 哈希表的实现是怎样的？如何解决哈希冲突？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Structures",
      "数据结构",
      "Hash Table",
      "哈希表",
      "Rehash"
    ],
    "difficulty": "Medium",
    "title": "Redis 的 rehash 过程是怎样的？什么是渐进式 rehash？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Structures",
      "数据结构",
      "Hash Table",
      "哈希表",
      "Rehash"
    ],
    "difficulty": "Medium",
    "title": "Redis rehash 的触发条件是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Structures",
      "数据结构",
      "Intset",
      "整数集合"
    ],
    "difficulty": "Medium",
    "title": "什么是整数集合（intset）？升级操作是怎样的？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Structures",
      "数据结构",
      "Skiplist",
      "跳表"
    ],
    "difficulty": "Medium",
    "title": "什么是跳表（skiplist）？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Structures",
      "数据结构",
      "Skiplist",
      "跳表",
      "Zset",
      "有序集合"
    ],
    "difficulty": "Hard",
    "title": "Redis Zset 为什么用跳表而不用平衡树？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Structures",
      "数据结构",
      "Quicklist"
    ],
    "difficulty": "Medium",
    "title": "什么是 quicklist？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Data Structures",
      "数据结构",
      "Listpack"
    ],
    "difficulty": "Medium",
    "title": "什么是 listpack？相比压缩列表有什么改进？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Expiration",
      "过期策略",
      "Eviction",
      "淘汰策略"
    ],
    "difficulty": "Medium",
    "title": "Redis 过期删除策略和内存淘汰策略有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Expiration",
      "过期策略"
    ],
    "difficulty": "Easy",
    "title": "Redis 如何设置 key 的过期时间？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Expiration",
      "过期策略"
    ],
    "difficulty": "Easy",
    "title": "Redis 如何判断 key 是否已过期？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Expiration",
      "过期策略"
    ],
    "difficulty": "Medium",
    "title": "Redis 的过期删除策略有哪些？（惰性删除+定期删除）"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Configuration",
      "配置",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Easy",
    "title": "Redis 如何设置最大运行内存？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Eviction",
      "淘汰策略",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "Redis 内存淘汰策略有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Eviction",
      "淘汰策略",
      "LRU",
      "LFU",
      "Algorithms",
      "算法"
    ],
    "difficulty": "Hard",
    "title": "LRU 算法和 LFU 算法有什么区别？Redis 如何实现它们？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Persistence",
      "持久化",
      "AOF",
      "Big Key",
      "大 Key"
    ],
    "difficulty": "Medium",
    "title": "Redis 大 Key 对 AOF 持久化有什么影响？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Persistence",
      "持久化",
      "RDB",
      "AOF Rewrite",
      "AOF重写",
      "Big Key",
      "大 Key",
      "Fork"
    ],
    "difficulty": "Hard",
    "title": "Redis 大 Key 对 RDB 持久化和 AOF 重写有什么影响？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Performance",
      "性能",
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "Linux 内存大页机制对 Redis 性能有什么影响？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Performance",
      "性能",
      "Big Key",
      "大 Key"
    ],
    "difficulty": "Medium",
    "title": "Redis 大 Key 还有哪些其他影响？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Best Practices",
      "最佳实践",
      "Big Key",
      "大 Key"
    ],
    "difficulty": "Medium",
    "title": "如何避免和处理 Redis 大 Key？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Persistence",
      "持久化",
      "RDB"
    ],
    "difficulty": "Medium",
    "title": "RDB 快照是怎么实现的？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Persistence",
      "持久化",
      "RDB"
    ],
    "difficulty": "Easy",
    "title": "Redis 如何生成 RDB 文件？save 和 bgsave 的区别？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Persistence",
      "持久化",
      "RDB",
      "Concurrency",
      "并发",
      "Copy-on-Write",
      "写时复制"
    ],
    "difficulty": "Medium",
    "title": "执行 RDB 快照（bgsave）时，数据能被修改吗？如何实现的？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Persistence",
      "持久化",
      "RDB",
      "AOF"
    ],
    "difficulty": "Medium",
    "title": "RDB 和 AOF 混合持久化是怎么回事？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Persistence",
      "持久化",
      "AOF"
    ],
    "difficulty": "Medium",
    "title": "AOF 持久化是怎么实现的？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Persistence",
      "持久化",
      "AOF"
    ],
    "difficulty": "Medium",
    "title": "AOF 的三种写回策略是什么？有什么优缺点？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Persistence",
      "持久化",
      "AOF",
      "AOF Rewrite",
      "AOF重写"
    ],
    "difficulty": "Medium",
    "title": "Redis 的 AOF 重写机制是为了解决什么问题？过程是怎样的？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Redis",
      "Persistence",
      "持久化",
      "AOF",
      "AOF Rewrite",
      "AOF重写",
      "Concurrency",
      "并发",
      "Copy-on-Write",
      "写时复制"
    ],
    "difficulty": "Hard",
    "title": "AOF 后台重写（bgrewriteaof）是如何工作的？如何处理重写期间的数据修改？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Operating System",
      "操作系统",
      "Linux Networking",
      "Linux网络"
    ],
    "difficulty": "Hard",
    "title": "Linux 系统是如何收发网络包的？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP/IP",
      "OSI Model",
      "网络模型"
    ],
    "difficulty": "Medium",
    "title": "OSI 模型和 TCP/IP 模型有什么区别？各自有哪几层？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP/IP",
      "Packet Encapsulation",
      "数据包封装"
    ],
    "difficulty": "Medium",
    "title": "请描述网络数据包在 TCP/IP 模型中的封装过程。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP",
      "MTU",
      "Packet Fragmentation",
      "数据包分片"
    ],
    "difficulty": "Medium",
    "title": "什么是 MTU？网络包超过 MTU 会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Operating System",
      "操作系统",
      "Linux Networking",
      "Linux网络",
      "NAPI",
      "Interrupt Handling",
      "中断处理"
    ],
    "difficulty": "Hard",
    "title": "什么是 NAPI 机制？它解决了什么问题？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Operating System",
      "操作系统",
      "Linux Networking",
      "Linux网络",
      "Packet Processing",
      "数据包处理"
    ],
    "difficulty": "Medium",
    "title": "简述 Linux 接收网络包的详细流程。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Operating System",
      "操作系统",
      "Linux Networking",
      "Linux网络",
      "Packet Processing",
      "数据包处理",
      "sk_buff"
    ],
    "difficulty": "Medium",
    "title": "简述 Linux 发送网络包的详细流程。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Operating System",
      "操作系统",
      "Linux Networking",
      "Linux网络",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "Linux 发送网络数据时涉及几次内存拷贝？为什么需要拷贝？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP/IP",
      "Network Model",
      "网络模型"
    ],
    "difficulty": "Easy",
    "title": "TCP/IP 网络模型分为哪几层？各自的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP/IP",
      "Transport Layer",
      "传输层",
      "TCP",
      "UDP"
    ],
    "difficulty": "Easy",
    "title": "传输层有哪些主要协议？TCP 和 UDP 有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP/IP",
      "Network Layer",
      "网络层",
      "IP",
      "Routing",
      "路由",
      "Addressing",
      "寻址"
    ],
    "difficulty": "Medium",
    "title": "网络层的主要作用是什么？IP 地址和子网掩码如何工作？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP/IP",
      "Network Interface Layer",
      "网络接口层",
      "MAC Address",
      "MAC地址",
      "Ethernet",
      "以太网"
    ],
    "difficulty": "Medium",
    "title": "网络接口层的作用是什么？为什么需要 MAC 地址？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "DNS",
      "TCP",
      "IP",
      "Web",
      "浏览器"
    ],
    "difficulty": "Hard",
    "title": "键入网址到网页显示，期间发生了什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "DNS"
    ],
    "difficulty": "Medium",
    "title": "请描述 DNS 域名解析的详细过程。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "Connection Establishment",
      "连接建立"
    ],
    "difficulty": "Medium",
    "title": "请描述 TCP 三次握手的过程及其目的。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP",
      "Routing",
      "路由"
    ],
    "difficulty": "Medium",
    "title": "路由器是如何根据 IP 地址转发数据包的？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Ethernet",
      "以太网",
      "MAC Address",
      "MAC地址",
      "Switching",
      "交换"
    ],
    "difficulty": "Medium",
    "title": "交换机是如何根据 MAC 地址转发数据帧的？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "ARP"
    ],
    "difficulty": "Medium",
    "title": "ARP 协议的作用是什么？它是如何工作的？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "MAC Address",
      "MAC地址",
      "IP Address",
      "IP地址"
    ],
    "difficulty": "Medium",
    "title": "在数据包传输过程中，源/目的 IP 地址和源/目的 MAC 地址是如何变化的？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "HTTP/1.1 有哪些主要的性能问题？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如何优化 HTTP/1.1 的性能？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "HTTP/2 如何实现对 HTTP/1.1 的兼容？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "解释 HTTP/2 的头部压缩机制 (HPACK)。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "解释 HTTP/2 的二进制分帧层。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "HTTP/2 如何通过多路复用解决 HTTP/1.1 的队头阻塞问题？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "解释 HTTP/2 的服务器推送 (Server Push) 功能。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "TCP"
    ],
    "difficulty": "Hard",
    "title": "HTTP/2 是否完全解决了队头阻塞问题？解释 TCP 层面的队头阻塞。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "HTTP/2 相比 HTTP/1.1 存在哪些缺点或仍需改进的地方？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "TCP",
      "TLS/SSL"
    ],
    "difficulty": "Medium",
    "title": "解释基于 TCP 的 HTTP 连接建立过程中的握手延迟。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "TCP"
    ],
    "difficulty": "Medium",
    "title": "为什么基于 TCP 的 HTTP 在网络切换（如 4G 到 WiFi）时需要重新建立连接？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "UDP",
      "QUIC"
    ],
    "difficulty": "Medium",
    "title": "QUIC 协议的主要特点有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "UDP",
      "QUIC",
      "TCP"
    ],
    "difficulty": "Hard",
    "title": "QUIC 协议如何解决队头阻塞问题？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "UDP",
      "QUIC",
      "TLS/SSL"
    ],
    "difficulty": "Hard",
    "title": "QUIC 协议如何实现更快的连接建立（0-RTT/1-RTT）？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "UDP",
      "QUIC"
    ],
    "difficulty": "Medium",
    "title": "解释 QUIC 协议的连接迁移特性。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "HTTP/3 相比 HTTP/2 做了哪些主要改进？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Hard",
    "title": "QPACK 是什么？它与 HPACK 的主要区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "HTTP 是什么？请解释超文本传输协议。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "请列举并解释一些常见的 HTTP 状态码。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "请列举并解释一些常见的 HTTP 请求/响应头字段。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "GET 请求和 POST 请求有哪些主要区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "GET 和 POST 方法是安全的或幂等的吗？请解释。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "GET 请求的 URL 中可以携带 body 数据吗？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "HTTP 缓存机制有哪些？解释强制缓存和协商缓存。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "HTTP/1.1 有哪些优点和缺点？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "评价 HTTP/1.1 的性能，并讨论长连接、管道化和队头阻塞。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTPS",
      "Security",
      "安全"
    ],
    "difficulty": "Easy",
    "title": "HTTP 和 HTTPS 的主要区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTPS",
      "Security",
      "安全"
    ],
    "difficulty": "Medium",
    "title": "HTTPS 主要解决了 HTTP 的哪些安全问题？如何解决的？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "TLS/SSL",
      "Security",
      "安全"
    ],
    "difficulty": "Hard",
    "title": "描述 HTTPS 的连接建立过程（TLS 握手）。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "TLS/SSL",
      "Security",
      "安全"
    ],
    "difficulty": "Hard",
    "title": "客户端如何校验服务器发送的数字证书？解释证书链。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "TLS/SSL",
      "Security",
      "安全"
    ],
    "difficulty": "Medium",
    "title": "HTTPS 如何保证应用数据的完整性？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "Security",
      "安全"
    ],
    "difficulty": "Hard",
    "title": "HTTPS 一定是安全的吗？讨论中间人攻击的可能性。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "Security",
      "安全"
    ],
    "difficulty": "Hard",
    "title": "为什么 Wireshark 等抓包工具能够抓取并解密 HTTPS 流量？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "Security",
      "安全"
    ],
    "difficulty": "Medium",
    "title": "如何防止 HTTPS 数据被中间人攻击截取？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "HTTP/1.1 相比 HTTP/1.0 在性能上有哪些改进？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "HTTP/2 相比 HTTP/1.1 做了哪些性能优化？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "HTTP/3 相比 HTTP/2 做了哪些性能优化？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如何通过缓存技术优化 HTTP/1.1 性能？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如何通过减少请求次数（如重定向优化、请求合并、延迟加载）优化 HTTP/1.1 性能？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如何通过压缩减少 HTTP 响应数据大小来优化性能？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "RPC"
    ],
    "difficulty": "Medium",
    "title": "既然有 HTTP 协议，为什么还需要 RPC？它们的主要区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP"
    ],
    "difficulty": "Medium",
    "title": "直接使用 TCP 协议传输数据会遇到什么问题？（如粘包）"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "WebSocket"
    ],
    "difficulty": "Medium",
    "title": "既然有 HTTP 协议，为什么还需要 WebSocket？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "WebSocket"
    ],
    "difficulty": "Medium",
    "title": "除了 WebSocket，还有哪些方式可以实现服务器向客户端推送消息？（轮询、长轮询）"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "WebSocket"
    ],
    "difficulty": "Easy",
    "title": "WebSocket 是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "WebSocket",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "WebSocket 连接是如何建立的？它和 HTTP 的关系是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "WebSocket"
    ],
    "difficulty": "Easy",
    "title": "WebSocket 适用于哪些应用场景？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "Cryptography",
      "密码学"
    ],
    "difficulty": "Hard",
    "title": "解释离散对数及其在 DH 密钥交换算法中的应用。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "Cryptography",
      "密码学",
      "Security",
      "安全"
    ],
    "difficulty": "Hard",
    "title": "DHE 与 DH 算法有何不同？什么是前向保密性？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "Cryptography",
      "密码学"
    ],
    "difficulty": "Hard",
    "title": "解释 ECDHE 密钥交换算法的原理。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "TLS/SSL"
    ],
    "difficulty": "Hard",
    "title": "描述使用 ECDHE 算法的 TLS 握手过程。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "TLS/SSL",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "ECDHE 握手相比 RSA 握手有哪些优势？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "HTTPS 的性能瓶颈主要在哪里？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如何从硬件、软件和协议层面优化 HTTPS 性能？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "TLS/SSL",
      "Performance Optimization",
      "性能优化",
      "Security",
      "安全"
    ],
    "difficulty": "Medium",
    "title": "如何优化 HTTPS 证书（大小、验证过程如 OCSP Stapling）？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "TLS/SSL",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Hard",
    "title": "解释 HTTPS 会话复用技术（Session ID, Session Ticket, Pre-shared Key）的原理、优缺点。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "TLS/SSL"
    ],
    "difficulty": "Hard",
    "title": "描述使用 RSA 算法的 TLS 握手过程。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTPS",
      "Cryptography",
      "密码学",
      "Security",
      "安全"
    ],
    "difficulty": "Medium",
    "title": "使用 RSA 进行密钥协商存在什么主要缺陷？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Handshake",
      "握手"
    ],
    "difficulty": "Medium",
    "title": "已建立连接的 TCP 收到 SYN 会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Teardown",
      "连接断开",
      "Tools",
      "工具"
    ],
    "difficulty": "Medium",
    "title": "如何关闭一个 TCP 连接？（killcx/tcpkill）"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Tools",
      "工具"
    ],
    "difficulty": "Medium",
    "title": "killcx 和 tcpkill 工具的区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Handshake",
      "握手",
      "Reliability",
      "可靠性"
    ],
    "difficulty": "Medium",
    "title": "为什么 TCP 初始化序列号 ISN 要不同？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "TIME_WAIT",
      "TIME_WAIT",
      "Reliability",
      "可靠性"
    ],
    "difficulty": "Medium",
    "title": "TIME_WAIT 状态与历史报文的关系？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Timestamp",
      "时间戳",
      "Reliability",
      "可靠性"
    ],
    "difficulty": "Hard",
    "title": "TCP 时间戳回绕问题及处理？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Teardown",
      "连接断开",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Hard",
    "title": "四次挥手中收到乱序 FIN 包的处理？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "UDP",
      "UDP",
      "Socket",
      "套接字"
    ],
    "difficulty": "Easy",
    "title": "TCP 和 UDP 可以绑定相同端口吗？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Socket",
      "套接字"
    ],
    "difficulty": "Medium",
    "title": "多个 TCP 服务进程可以绑定同一端口吗？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Socket",
      "套接字",
      "TIME_WAIT",
      "TIME_WAIT"
    ],
    "difficulty": "Medium",
    "title": "重启 TCP 服务时 Address in use 报错原因及避免方法？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Socket",
      "套接字"
    ],
    "difficulty": "Medium",
    "title": "客户端端口可以重复使用吗？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "TIME_WAIT",
      "TIME_WAIT",
      "Troubleshooting",
      "问题排查"
    ],
    "difficulty": "Medium",
    "title": "客户端 TIME_WAIT 过多会导致端口耗尽吗？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "TIME_WAIT",
      "TIME_WAIT",
      "Optimization",
      "优化"
    ],
    "difficulty": "Medium",
    "title": "如何解决客户端 TIME_WAIT 过多问题？(tcp_tw_reuse)"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "UDP",
      "UDP",
      "Reliability",
      "可靠性",
      "QUIC",
      "QUIC"
    ],
    "difficulty": "Hard",
    "title": "如何基于 UDP 实现可靠传输？(QUIC)"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "QUIC",
      "QUIC",
      "Reliability",
      "可靠性"
    ],
    "difficulty": "Hard",
    "title": "QUIC 如何实现可靠传输？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "QUIC",
      "QUIC",
      "Performance",
      "性能",
      "HOL Blocking",
      "队头阻塞"
    ],
    "difficulty": "Medium",
    "title": "QUIC 如何解决 TCP 队头阻塞？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "QUIC",
      "QUIC",
      "Flow Control",
      "流量控制"
    ],
    "difficulty": "Medium",
    "title": "QUIC 如何实现流量控制？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "QUIC",
      "QUIC",
      "Congestion Control",
      "拥塞控制"
    ],
    "difficulty": "Medium",
    "title": "QUIC 如何改进拥塞控制？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "QUIC",
      "QUIC",
      "Performance",
      "性能",
      "Handshake",
      "握手"
    ],
    "difficulty": "Medium",
    "title": "QUIC 如何实现更快的连接建立？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "QUIC",
      "QUIC",
      "Connection Migration",
      "连接迁移"
    ],
    "difficulty": "Medium",
    "title": "QUIC 如何实现连接迁移？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Handshake",
      "握手",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Medium",
    "title": "SYN 报文在什么情况下会被丢弃？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "TIME_WAIT",
      "TIME_WAIT",
      "Optimization",
      "优化"
    ],
    "difficulty": "Hard",
    "title": "tcp_tw_recycle 参数的作用及风险？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Timestamp",
      "时间戳",
      "Reliability",
      "可靠性"
    ],
    "difficulty": "Medium",
    "title": "TCP PAWS 机制的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Timestamp",
      "时间戳",
      "NAT",
      "NAT"
    ],
    "difficulty": "Hard",
    "title": "per-host PAWS 机制及其在 NAT 下的问题？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Queue",
      "队列",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Medium",
    "title": "TCP 全连接队列满了会发生什么？如何处理？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Queue",
      "队列",
      "Exception Handling",
      "异常处理",
      "SYN Flood",
      "SYN 攻击"
    ],
    "difficulty": "Medium",
    "title": "TCP 半连接队列满了会发生什么？如何处理？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Queue",
      "队列",
      "SYN Flood",
      "SYN 攻击"
    ],
    "difficulty": "Medium",
    "title": "TCP syncookies 的作用和原理？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Security",
      "安全",
      "SYN Flood",
      "SYN 攻击"
    ],
    "difficulty": "Medium",
    "title": "如何防御 SYN 攻击？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Medium",
    "title": "TCP 连接中，对端断电和进程崩溃有何区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Medium",
    "title": "客户端主机宕机后迅速重启，TCP 连接会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Exception Handling",
      "异常处理",
      "Timeout",
      "超时"
    ],
    "difficulty": "Medium",
    "title": "客户端主机宕机且未重启，TCP 连接会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Reliability",
      "可靠性",
      "Retransmission",
      "重传"
    ],
    "difficulty": "Medium",
    "title": "TCP 数据报文超时重传次数由哪个参数控制？(tcp_retries2)"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Reliability",
      "可靠性"
    ],
    "difficulty": "Medium",
    "title": "TCP 能保证数据一定不丢失吗？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Troubleshooting",
      "问题排查"
    ],
    "difficulty": "Medium",
    "title": "网络数据包可能在哪些环节丢失？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Reliability",
      "可靠性"
    ],
    "difficulty": "Easy",
    "title": "TCP 如何处理丢包？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Reliability",
      "可靠性"
    ],
    "difficulty": "Medium",
    "title": "为什么说 TCP 只保证传输层可靠性？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Application Layer",
      "应用层",
      "Reliability",
      "可靠性"
    ],
    "difficulty": "Medium",
    "title": "如何保证应用层数据可靠性？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Reliability",
      "可靠性"
    ],
    "difficulty": "Easy",
    "title": "TCP 如何保证可靠传输？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Reliability",
      "可靠性",
      "Retransmission",
      "重传"
    ],
    "difficulty": "Medium",
    "title": "TCP 超时重传时间 RTO 如何设置？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Reliability",
      "可靠性",
      "Retransmission",
      "重传"
    ],
    "difficulty": "Medium",
    "title": "TCP 快速重传机制是如何工作的？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Reliability",
      "可靠性",
      "Retransmission",
      "重传"
    ],
    "difficulty": "Medium",
    "title": "TCP SACK 的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Reliability",
      "可靠性",
      "Retransmission",
      "重传"
    ],
    "difficulty": "Medium",
    "title": "TCP D-SACK 的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Sliding Window",
      "滑动窗口"
    ],
    "difficulty": "Easy",
    "title": "为什么 TCP 需要滑动窗口？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Sliding Window",
      "滑动窗口",
      "Flow Control",
      "流量控制"
    ],
    "difficulty": "Easy",
    "title": "TCP 窗口大小由哪一方决定？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Sliding Window",
      "滑动窗口"
    ],
    "difficulty": "Easy",
    "title": "TCP 接收窗口和发送窗口大小相等吗？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Flow Control",
      "流量控制"
    ],
    "difficulty": "Medium",
    "title": "TCP 流量控制是如何工作的？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Sliding Window",
      "滑动窗口",
      "Buffer",
      "缓冲区"
    ],
    "difficulty": "Medium",
    "title": "操作系统缓冲区与 TCP 滑动窗口的关系？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Flow Control",
      "流量控制",
      "Window Probe",
      "窗口探测"
    ],
    "difficulty": "Medium",
    "title": "TCP 零窗口探测机制的作用？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Performance",
      "性能",
      "Nagle",
      "Nagle算法"
    ],
    "difficulty": "Medium",
    "title": "什么是 TCP 糊涂窗口综合症？如何解决？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Congestion Control",
      "拥塞控制",
      "Flow Control",
      "流量控制"
    ],
    "difficulty": "Easy",
    "title": "TCP 拥塞控制和流量控制的区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Congestion Control",
      "拥塞控制"
    ],
    "difficulty": "Easy",
    "title": "TCP 如何判断网络拥塞？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Congestion Control",
      "拥塞控制"
    ],
    "difficulty": "Medium",
    "title": "TCP 拥塞控制算法有哪些？（慢启动、拥塞避免、拥塞发生、快速恢复）"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "TCP Keepalive 和 HTTP Keep-Alive 的区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP"
    ],
    "difficulty": "Easy",
    "title": "TCP 头部格式包含哪些主要字段？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "OSI Model",
      "OSI模型"
    ],
    "difficulty": "Easy",
    "title": "为什么需要 TCP 协议？它工作在哪一层？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP"
    ],
    "difficulty": "Easy",
    "title": "请简述 TCP 协议的特点？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP"
    ],
    "difficulty": "Easy",
    "title": "什么是 TCP 连接？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Socket",
      "套接字"
    ],
    "difficulty": "Easy",
    "title": "如何唯一确定一个 TCP 连接？（TCP 四元组）"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Scalability",
      "可扩展性"
    ],
    "difficulty": "Medium",
    "title": "服务器单机最大 TCP 连接数理论上限是多少？受哪些因素限制？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "UDP",
      "UDP"
    ],
    "difficulty": "Easy",
    "title": "TCP 和 UDP 的区别及应用场景？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "UDP",
      "UDP"
    ],
    "difficulty": "Medium",
    "title": "为什么 UDP 头没有首部长度而 TCP 有？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "UDP",
      "UDP"
    ],
    "difficulty": "Medium",
    "title": "为什么 UDP 头有包长度而 TCP 没有？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Handshake",
      "握手"
    ],
    "difficulty": "Easy",
    "title": "请描述 TCP 三次握手过程？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Linux",
      "Linux",
      "Troubleshooting",
      "问题排查"
    ],
    "difficulty": "Easy",
    "title": "如何在 Linux 中查看 TCP 连接状态？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Handshake",
      "握手"
    ],
    "difficulty": "Medium",
    "title": "为什么 TCP 需要三次握手？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Handshake",
      "握手",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Medium",
    "title": "TCP 第一次握手丢失会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Handshake",
      "握手",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Medium",
    "title": "TCP 第二次握手丢失会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Handshake",
      "握手",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Medium",
    "title": "TCP 第三次握手丢失会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Security",
      "安全",
      "SYN Flood",
      "SYN 攻击"
    ],
    "difficulty": "Medium",
    "title": "什么是 SYN 攻击？如何防御？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Teardown",
      "连接断开"
    ],
    "difficulty": "Easy",
    "title": "请描述 TCP 四次挥手过程？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Teardown",
      "连接断开"
    ],
    "difficulty": "Easy",
    "title": "为什么 TCP 挥手需要四次？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Teardown",
      "连接断开",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Medium",
    "title": "TCP 第一次挥手丢失会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Teardown",
      "连接断开",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Medium",
    "title": "TCP 第二次挥手丢失会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Teardown",
      "连接断开",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Medium",
    "title": "TCP 第三次挥手丢失会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Teardown",
      "连接断开",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Medium",
    "title": "TCP 第四次挥手丢失会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "TIME_WAIT",
      "TIME_WAIT"
    ],
    "difficulty": "Medium",
    "title": "为什么 TIME_WAIT 状态要等待 2MSL？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "TIME_WAIT",
      "TIME_WAIT"
    ],
    "difficulty": "Medium",
    "title": "TIME_WAIT 状态的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "TIME_WAIT",
      "TIME_WAIT",
      "Troubleshooting",
      "问题排查"
    ],
    "difficulty": "Medium",
    "title": "TIME_WAIT 状态过多有什么危害？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "TIME_WAIT",
      "TIME_WAIT",
      "Optimization",
      "优化"
    ],
    "difficulty": "Medium",
    "title": "如何优化 TIME_WAIT 状态？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "TIME_WAIT",
      "TIME_WAIT",
      "Troubleshooting",
      "问题排查"
    ],
    "difficulty": "Hard",
    "title": "服务器出现大量 TIME_WAIT 状态的原因？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "CLOSE_WAIT",
      "CLOSE_WAIT",
      "Troubleshooting",
      "问题排查"
    ],
    "difficulty": "Hard",
    "title": "服务器出现大量 CLOSE_WAIT 状态的原因？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Exception Handling",
      "异常处理",
      "Keepalive",
      "保活"
    ],
    "difficulty": "Medium",
    "title": "TCP 连接建立后，客户端突然故障怎么办？(TCP Keepalive)"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Medium",
    "title": "TCP 连接建立后，服务端进程崩溃会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Socket",
      "套接字",
      "TCP",
      "TCP"
    ],
    "difficulty": "Easy",
    "title": "请描述 TCP Socket 编程的基本流程？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Socket",
      "套接字",
      "TCP",
      "TCP",
      "Queue",
      "队列"
    ],
    "difficulty": "Medium",
    "title": "TCP listen 函数 backlog 参数的意义？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Socket",
      "套接字",
      "TCP",
      "TCP",
      "Handshake",
      "握手"
    ],
    "difficulty": "Medium",
    "title": "TCP accept 函数发生在三次握手的哪一步？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Socket",
      "套接字",
      "TCP",
      "TCP",
      "Teardown",
      "连接断开"
    ],
    "difficulty": "Medium",
    "title": "客户端调用 close 函数后 TCP 连接断开的流程？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Handshake",
      "握手",
      "Socket",
      "套接字"
    ],
    "difficulty": "Medium",
    "title": "没有 accept 函数调用，TCP 连接能建立吗？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Queue",
      "队列"
    ],
    "difficulty": "Easy",
    "title": "什么是 TCP 半连接队列和全连接队列？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Queue",
      "队列",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Medium",
    "title": "为什么 TCP 半连接队列设计成哈希表？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Linux",
      "Linux",
      "Troubleshooting",
      "问题排查"
    ],
    "difficulty": "Easy",
    "title": "如何查看 TCP 半连接和全连接队列的大小及溢出？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Handshake",
      "握手",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Medium",
    "title": "服务端没有 listen 时，客户端发起连接会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Handshake",
      "握手"
    ],
    "difficulty": "Medium",
    "title": "不调用 listen 函数，能建立 TCP 连接吗？（自连接/同时打开）"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Handshake",
      "握手",
      "Internals",
      "内核"
    ],
    "difficulty": "Hard",
    "title": "为什么没有 listen 也能建立 TCP 连接？（内核全局哈希表）"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Optimization",
      "优化",
      "Handshake",
      "握手"
    ],
    "difficulty": "Medium",
    "title": "如何优化客户端 SYN_SENT 状态？(tcp_syn_retries)"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Optimization",
      "优化",
      "Handshake",
      "握手",
      "Queue",
      "队列"
    ],
    "difficulty": "Hard",
    "title": "如何优化服务端 SYN_RCV 状态？（队列、syncookies、重传次数）"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Optimization",
      "优化",
      "Handshake",
      "握手",
      "Queue",
      "队列"
    ],
    "difficulty": "Hard",
    "title": "如何优化 TCP 全连接（accept）队列？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Optimization",
      "优化",
      "Performance",
      "性能",
      "TFO",
      "TCP Fast Open"
    ],
    "difficulty": "Medium",
    "title": "如何绕过 TCP 三次握手？(TCP Fast Open)"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Optimization",
      "优化",
      "Teardown",
      "连接断开"
    ],
    "difficulty": "Medium",
    "title": "如何优化 TCP FIN_WAIT1 状态？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Optimization",
      "优化",
      "Teardown",
      "连接断开"
    ],
    "difficulty": "Medium",
    "title": "如何优化 TCP FIN_WAIT2 状态？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Optimization",
      "优化",
      "TIME_WAIT",
      "TIME_WAIT"
    ],
    "difficulty": "Hard",
    "title": "如何优化 TCP TIME_WAIT 状态？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Optimization",
      "优化",
      "CLOSE_WAIT",
      "CLOSE_WAIT"
    ],
    "difficulty": "Medium",
    "title": "如何优化 TCP CLOSE_WAIT 状态？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Sliding Window",
      "滑动窗口",
      "Performance",
      "性能"
    ],
    "difficulty": "Medium",
    "title": "TCP 滑动窗口如何影响传输速度？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Performance",
      "性能",
      "Bandwidth",
      "带宽"
    ],
    "difficulty": "Medium",
    "title": "如何确定 TCP 最大传输速度？（带宽时延积 BDP）"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Optimization",
      "优化",
      "Buffer",
      "缓冲区"
    ],
    "difficulty": "Hard",
    "title": "如何调整 TCP 缓冲区大小以优化性能？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "OSI Model",
      "OSI模型"
    ],
    "difficulty": "Medium",
    "title": "为什么升级 TCP 协议很困难？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Handshake",
      "握手",
      "Performance",
      "性能"
    ],
    "difficulty": "Easy",
    "title": "TCP 建立连接的延迟主要来自哪里？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Performance",
      "性能",
      "HOL Blocking",
      "队头阻塞"
    ],
    "difficulty": "Medium",
    "title": "什么是 TCP 队头阻塞问题？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Connection Migration",
      "连接迁移"
    ],
    "difficulty": "Medium",
    "title": "为什么网络迁移（如 4G 切换 WiFi）需要重新建立 TCP 连接？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "UDP",
      "UDP"
    ],
    "difficulty": "Easy",
    "title": "如何理解 TCP 是面向字节流的协议？与 UDP 面向报文有何不同？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Application Layer",
      "应用层"
    ],
    "difficulty": "Medium",
    "title": "如何解决 TCP 粘包问题？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Tools",
      "工具"
    ],
    "difficulty": "Easy",
    "title": "tcpdump 和 Wireshark 的区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Tools",
      "工具",
      "Linux",
      "Linux"
    ],
    "difficulty": "Easy",
    "title": "如何在 Linux 下使用 tcpdump 抓包？（常用命令）"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Tools",
      "工具"
    ],
    "difficulty": "Easy",
    "title": "如何使用 Wireshark 分析数据包？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Teardown",
      "连接断开"
    ],
    "difficulty": "Medium",
    "title": "为什么抓包时 TCP 挥手有时是三次？（延迟确认）"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Optimization",
      "优化",
      "Performance",
      "性能",
      "TFO",
      "TCP Fast Open"
    ],
    "difficulty": "Medium",
    "title": "TCP Fast Open 的原理和作用？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Reliability",
      "可靠性",
      "Retransmission",
      "重传"
    ],
    "difficulty": "Medium",
    "title": "TCP 重复确认和快速重传是如何工作的？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Flow Control",
      "流量控制"
    ],
    "difficulty": "Medium",
    "title": "TCP 流量控制中的零窗口通知和窗口探测是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Performance",
      "性能",
      "Nagle",
      "Nagle算法"
    ],
    "difficulty": "Medium",
    "title": "TCP 延迟确认和 Nagle 算法的作用及潜在问题？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Teardown",
      "连接断开"
    ],
    "difficulty": "Medium",
    "title": "TCP 四次挥手在什么情况下会变成三次？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Socket",
      "套接字",
      "TCP",
      "TCP"
    ],
    "difficulty": "Medium",
    "title": "Socket 的 close 和 shutdown 函数有何区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Performance",
      "性能"
    ],
    "difficulty": "Medium",
    "title": "什么是 TCP 延迟确认机制？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "TLS",
      "TLS",
      "Handshake",
      "握手",
      "TFO",
      "TCP Fast Open"
    ],
    "difficulty": "Hard",
    "title": "HTTPS 中 TLS 和 TCP 能同时握手吗？（TFO + TLSv1.3）"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TLS",
      "TLS",
      "Handshake",
      "握手"
    ],
    "difficulty": "Medium",
    "title": "TLSv1.3 握手过程是怎样的？（1-RTT/0-RTT）"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "TIME_WAIT",
      "TIME_WAIT",
      "Optimization",
      "优化"
    ],
    "difficulty": "Hard",
    "title": "为什么 Linux 中 tcp_tw_reuse 参数默认是关闭的？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "TIME_WAIT",
      "TIME_WAIT"
    ],
    "difficulty": "Easy",
    "title": "什么是 TCP TIME_WAIT 状态？持续多久？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "TIME_WAIT",
      "TIME_WAIT",
      "Optimization",
      "优化"
    ],
    "difficulty": "Medium",
    "title": "tcp_tw_reuse 参数的作用是什么？需要什么前提条件？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "TIME_WAIT",
      "TIME_WAIT",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Hard",
    "title": "TIME_WAIT 状态收到 SYN 会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "TIME_WAIT",
      "TIME_WAIT",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Medium",
    "title": "TIME_WAIT 状态收到 RST 会断开连接吗？(tcp_rfc1337)"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "TCP",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Medium",
    "title": "拔掉网线后，原本的 TCP 连接还存在吗？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "OSI Model",
      "OSI模型",
      "TCP/IP Model",
      "TCP/IP模型"
    ],
    "difficulty": "Medium",
    "title": "网络层与数据链路层有什么关系？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP",
      "IP协议",
      "MAC Address",
      "MAC地址",
      "Routing",
      "路由"
    ],
    "difficulty": "Medium",
    "title": "为什么数据包转发过程中IP地址不变而MAC地址会变？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP Addressing",
      "IP编址",
      "IPv4"
    ],
    "difficulty": "Easy",
    "title": "解释IPv4地址分类（A、B、C、D、E类）"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP Addressing",
      "IP编址",
      "IPv4"
    ],
    "difficulty": "Easy",
    "title": "如何计算A、B、C类地址的最大主机数？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP Addressing",
      "IP编址",
      "Broadcast",
      "广播"
    ],
    "difficulty": "Medium",
    "title": "广播地址的用途是什么？解释本地广播和直接广播。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP Addressing",
      "IP编址",
      "Multicast",
      "组播"
    ],
    "difficulty": "Medium",
    "title": "组播地址（D类地址）的用途是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP Addressing",
      "IP编址",
      "IPv4"
    ],
    "difficulty": "Medium",
    "title": "IP地址分类的优缺点是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP Addressing",
      "IP编址",
      "CIDR"
    ],
    "difficulty": "Medium",
    "title": "解释无分类编址 CIDR。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP Addressing",
      "IP编址",
      "CIDR",
      "Subnetting",
      "子网划分"
    ],
    "difficulty": "Easy",
    "title": "在CIDR中如何区分网络号和主机号？（子网掩码或前缀长度）"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP Addressing",
      "IP编址",
      "Routing",
      "路由"
    ],
    "difficulty": "Medium",
    "title": "为什么要区分IP地址的网络号和主机号？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP Addressing",
      "IP编址",
      "Subnetting",
      "子网划分"
    ],
    "difficulty": "Medium",
    "title": "如何进行子网划分？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP Addressing",
      "IP编址"
    ],
    "difficulty": "Easy",
    "title": "解释公有IP地址和私有IP地址的区别。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP Addressing",
      "IP编址",
      "Routing",
      "路由"
    ],
    "difficulty": "Medium",
    "title": "IP地址如何用于路由控制？解释最长匹配原则。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP Addressing",
      "IP编址"
    ],
    "difficulty": "Easy",
    "title": "什么是环回地址（127.0.0.1）？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP",
      "IP协议",
      "Fragmentation",
      "分片",
      "MTU"
    ],
    "difficulty": "Medium",
    "title": "解释IP分片和重组过程。什么是MTU？重组在哪里发生？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IPv6",
      "IPv4"
    ],
    "difficulty": "Medium",
    "title": "IPv6相比IPv4有哪些主要优势？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP Addressing",
      "IP编址",
      "IPv6"
    ],
    "difficulty": "Easy",
    "title": "IPv6地址如何表示？解释其缩写规则。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP Addressing",
      "IP编址",
      "IPv6"
    ],
    "difficulty": "Medium",
    "title": "描述IPv6地址的结构和主要类型（单播、组播、任播）。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP Addressing",
      "IP编址",
      "IPv6"
    ],
    "difficulty": "Medium",
    "title": "解释IPv6单播地址的不同类型（链路本地、唯一本地、全局）。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP",
      "IP协议",
      "IPv4",
      "IPv6"
    ],
    "difficulty": "Medium",
    "title": "比较IPv4和IPv6的首部。IPv6移除了/改变了哪些字段，为什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "DNS"
    ],
    "difficulty": "Medium",
    "title": "解释DNS域名解析的过程。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "DNS"
    ],
    "difficulty": "Easy",
    "title": "描述域名的层级结构。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "ARP"
    ],
    "difficulty": "Medium",
    "title": "解释ARP协议的用途和工作原理。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "ARP"
    ],
    "difficulty": "Medium",
    "title": "ARP如何发现IP地址对应的MAC地址？（ARP请求/响应）"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "RARP"
    ],
    "difficulty": "Easy",
    "title": "什么是RARP协议？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "DHCP"
    ],
    "difficulty": "Medium",
    "title": "解释DHCP动态分配IP地址的过程（DORA）。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "DHCP"
    ],
    "difficulty": "Medium",
    "title": "什么是DHCP中继代理？为什么需要它？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "NAT"
    ],
    "difficulty": "Medium",
    "title": "解释NAT（网络地址转换）的原理。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "NAT",
      "NAPT"
    ],
    "difficulty": "Medium",
    "title": "解释NAPT（网络地址端口转换）及其如何帮助节省IP地址。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "NAT"
    ],
    "difficulty": "Hard",
    "title": "什么是NAT穿透技术？为什么需要它？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "ICMP"
    ],
    "difficulty": "Medium",
    "title": "什么是ICMP协议？它的主要功能是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "ICMP"
    ],
    "difficulty": "Medium",
    "title": "描述ICMP报文的主要类型（查询报文和差错报文）。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IGMP",
      "Multicast",
      "组播"
    ],
    "difficulty": "Medium",
    "title": "什么是IGMP协议？它在组播中的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IGMP",
      "Multicast",
      "组播"
    ],
    "difficulty": "Hard",
    "title": "解释IGMP的基本工作机制（例如，加入/离开组播组，查询）。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "ICMP",
      "Ping"
    ],
    "difficulty": "Medium",
    "title": "解释 ping 命令的工作原理。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "ICMP"
    ],
    "difficulty": "Medium",
    "title": "描述常见的ICMP差错报文类型（目标不可达、重定向、超时）。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "ICMP"
    ],
    "difficulty": "Medium",
    "title": "解释ICMP目标不可达报文及其常见代码。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "ICMP",
      "Routing",
      "路由"
    ],
    "difficulty": "Medium",
    "title": "解释ICMP重定向报文的作用。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "ICMP",
      "IP",
      "IP协议",
      "TTL"
    ],
    "difficulty": "Medium",
    "title": "解释ICMP超时报文以及TTL的作用。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "ICMP",
      "Traceroute"
    ],
    "difficulty": "Hard",
    "title": "解释 traceroute (或 tracert) 命令的工作原理。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "ICMP",
      "Traceroute",
      "MTU"
    ],
    "difficulty": "Hard",
    "title": "traceroute 如何用于路径MTU发现？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Ping",
      "Loopback",
      "回环地址"
    ],
    "difficulty": "Medium",
    "title": "断网了还能 ping 通 127.0.0.1 吗？为什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "Ping",
      "ICMP"
    ],
    "difficulty": "Medium",
    "title": "TCP 发送数据和使用 ping 命令有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Ping",
      "Loopback",
      "回环地址",
      "IP Addressing",
      "IP编址"
    ],
    "difficulty": "Medium",
    "title": "ping 回环地址 (127.0.0.1) 和 ping 本机IP地址有区别吗？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "IP Addressing",
      "IP编址",
      "Loopback",
      "回环地址",
      "DNS"
    ],
    "difficulty": "Medium",
    "title": "127.0.0.1、localhost 和 0.0.0.0 有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Query Processing",
      "查询处理"
    ],
    "difficulty": "Medium",
    "title": "MySQL查询执行流程详解"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Architecture",
      "架构"
    ],
    "difficulty": "Easy",
    "title": "MySQL Server层与存储引擎层职责"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Connection",
      "连接管理"
    ],
    "difficulty": "Medium",
    "title": "MySQL连接器的工作原理"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Connection",
      "连接管理"
    ],
    "difficulty": "Medium",
    "title": "MySQL长连接与短连接的区别与优缺点"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Connection",
      "连接管理",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "解决MySQL长连接内存占用问题"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Query Cache",
      "查询缓存",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "MySQL查询缓存机制及8.0废弃原因"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Query Processing",
      "查询处理"
    ],
    "difficulty": "Medium",
    "title": "MySQL解析器与预处理阶段的工作"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Query Optimization",
      "查询优化"
    ],
    "difficulty": "Medium",
    "title": "MySQL优化器的作用"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Query Processing",
      "查询处理"
    ],
    "difficulty": "Medium",
    "title": "MySQL执行器的工作原理"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Query Optimization",
      "查询优化"
    ],
    "difficulty": "Medium",
    "title": "MySQL索引下推 (ICP) 详解"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "Storage",
      "存储结构"
    ],
    "difficulty": "Medium",
    "title": "MySQL InnoDB行存储格式详解"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "Storage",
      "存储结构"
    ],
    "difficulty": "Medium",
    "title": "InnoDB表空间结构 (段、区、页、行)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "Storage",
      "存储结构"
    ],
    "difficulty": "Medium",
    "title": "COMPACT行格式详解"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Storage",
      "存储结构"
    ],
    "difficulty": "Easy",
    "title": "MySQL中NULL值的存储"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Data Types",
      "数据类型",
      "Storage",
      "存储结构"
    ],
    "difficulty": "Medium",
    "title": "VARCHAR类型实际长度存储"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Data Types",
      "数据类型",
      "Limits",
      "限制"
    ],
    "difficulty": "Medium",
    "title": "VARCHAR(n)的最大长度限制及原因"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "Storage",
      "存储结构"
    ],
    "difficulty": "Medium",
    "title": "MySQL行溢出处理机制"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "Buffer Pool",
      "缓冲池",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Easy",
    "title": "MySQL Buffer Pool的作用与原理"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "Buffer Pool",
      "缓冲池",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Medium",
    "title": "Buffer Pool管理机制 (Free/Flush/LRU链表)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "Buffer Pool",
      "缓冲池",
      "Algorithms",
      "算法"
    ],
    "difficulty": "Hard",
    "title": "InnoDB LRU算法优化 (冷热分离、停留时间)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "Buffer Pool",
      "缓冲池",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "Buffer Pool预读失效及解决"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "Buffer Pool",
      "缓冲池",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "Buffer Pool污染及解决"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "Buffer Pool",
      "缓冲池"
    ],
    "difficulty": "Medium",
    "title": "Buffer Pool脏页刷盘时机"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Limits",
      "限制"
    ],
    "difficulty": "Medium",
    "title": "MySQL单表最大行数及限制因素"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "Index",
      "索引",
      "Storage",
      "存储结构",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Medium",
    "title": "InnoDB索引结构与数据存储 (表空间、页)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Medium",
    "title": "估算B+树索引容量"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "MySQL单表2000万行限制是否靠谱"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "SQL",
      "SQL",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "count(*), count(1), count(字段)的区别与性能"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "MyISAM",
      "MyISAM",
      "Storage Engine",
      "存储引擎"
    ],
    "difficulty": "Medium",
    "title": "InnoDB与MyISAM执行count()的差异"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "SQL",
      "SQL",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "优化大表count(*)查询"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引"
    ],
    "difficulty": "Easy",
    "title": "什么是数据库索引"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引"
    ],
    "difficulty": "Medium",
    "title": "MySQL索引分类"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Medium",
    "title": "B+树索引结构详解"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "Index",
      "索引"
    ],
    "difficulty": "Medium",
    "title": "聚簇索引与二级索引的区别"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "回表与覆盖索引"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Medium",
    "title": "MySQL为何选择B+树作为索引 (对比B树, Hash等)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引"
    ],
    "difficulty": "Medium",
    "title": "主键/唯一/普通/前缀索引的区别"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引"
    ],
    "difficulty": "Medium",
    "title": "联合索引与最左匹配原则"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Query Optimization",
      "查询优化"
    ],
    "difficulty": "Hard",
    "title": "联合索引范围查询与最左匹配原则的应用"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Design",
      "设计"
    ],
    "difficulty": "Medium",
    "title": "联合索引字段顺序选择 (区分度)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Performance",
      "性能优化",
      "SQL",
      "SQL"
    ],
    "difficulty": "Medium",
    "title": "利用联合索引优化ORDER BY"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Design",
      "设计"
    ],
    "difficulty": "Medium",
    "title": "索引创建时机选择 (何时创建/不创建)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "索引优化方法总结"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Design",
      "设计",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "为何推荐使用自增主键"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Design",
      "设计",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "为何推荐索引列NOT NULL"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Query Optimization",
      "查询优化"
    ],
    "difficulty": "Medium",
    "title": "索引失效的场景有哪些"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Query Optimization",
      "查询优化",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "通过执行计划分析索引使用情况"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Query Optimization",
      "查询优化"
    ],
    "difficulty": "Medium",
    "title": "like '%x'一定会导致索引失效吗"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Query Optimization",
      "查询优化"
    ],
    "difficulty": "Medium",
    "title": "覆盖索引对like '%x'查询的影响"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "MyISAM",
      "MyISAM",
      "Index",
      "索引",
      "Storage",
      "存储结构"
    ],
    "difficulty": "Medium",
    "title": "InnoDB与MyISAM索引存储结构对比"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Query Optimization",
      "查询优化"
    ],
    "difficulty": "Medium",
    "title": "模糊查询(%xx)导致索引失效的原因"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Query Optimization",
      "查询优化"
    ],
    "difficulty": "Medium",
    "title": "索引列使用函数导致失效的原因"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引"
    ],
    "difficulty": "Medium",
    "title": "函数索引 (MySQL 8.0)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Query Optimization",
      "查询优化"
    ],
    "difficulty": "Medium",
    "title": "索引列表达式计算导致失效的原因"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Query Optimization",
      "查询优化"
    ],
    "difficulty": "Medium",
    "title": "索引列隐式类型转换导致失效的原因"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Query Optimization",
      "查询优化"
    ],
    "difficulty": "Medium",
    "title": "OR条件导致索引失效的情况"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "Storage",
      "存储结构"
    ],
    "difficulty": "Medium",
    "title": "InnoDB数据页结构详解"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Index",
      "索引",
      "Data Structures",
      "数据结构",
      "Query Processing",
      "查询处理"
    ],
    "difficulty": "Medium",
    "title": "B+树查询过程 (结合数据页)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁",
      "Deadlock",
      "死锁"
    ],
    "difficulty": "Hard",
    "title": "MySQL死锁场景复现与原因分析"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁"
    ],
    "difficulty": "Medium",
    "title": "间隙锁的兼容性与作用"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁"
    ],
    "difficulty": "Medium",
    "title": "插入意向锁详解及其与间隙锁关系"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁"
    ],
    "difficulty": "Hard",
    "title": "INSERT语句的加锁机制 (隐式/显式锁)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁"
    ],
    "difficulty": "Hard",
    "title": "唯一键冲突时的加锁行为 (主键 vs 唯一二级索引)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁",
      "Deadlock",
      "死锁"
    ],
    "difficulty": "Medium",
    "title": "MySQL死锁避免与解决策略"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁"
    ],
    "difficulty": "Easy",
    "title": "哪些SQL语句会加行级锁"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁"
    ],
    "difficulty": "Medium",
    "title": "MySQL行级锁类型详解 (记录锁, 间隙锁, Next-Key)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁"
    ],
    "difficulty": "Hard",
    "title": "MySQL行级锁加锁基本规则 (RR级别)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁",
      "Index",
      "索引"
    ],
    "difficulty": "Hard",
    "title": "唯一索引等值查询加锁规则"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁",
      "Index",
      "索引"
    ],
    "difficulty": "Hard",
    "title": "唯一索引范围查询加锁规则"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁",
      "Index",
      "索引"
    ],
    "difficulty": "Hard",
    "title": "非唯一索引等值查询加锁规则"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁",
      "Index",
      "索引"
    ],
    "difficulty": "Hard",
    "title": "非唯一索引范围查询加锁规则"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "无索引查询/更新的加锁行为 (锁全表风险)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁",
      "Troubleshooting",
      "问题排查"
    ],
    "difficulty": "Medium",
    "title": "使用performance_schema分析锁信息"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁",
      "Transaction",
      "事务",
      "Phantom Read",
      "幻读"
    ],
    "difficulty": "Hard",
    "title": "记录锁+间隙锁能否防止删除导致的幻读"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁"
    ],
    "difficulty": "Easy",
    "title": "MySQL锁分类 (全局锁、表级锁、行锁)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁"
    ],
    "difficulty": "Medium",
    "title": "MySQL全局锁详解 (用途、影响、替代方案)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁"
    ],
    "difficulty": "Medium",
    "title": "MySQL表级锁详解 (表锁、MDL、意向锁、AUTO-INC)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁"
    ],
    "difficulty": "Medium",
    "title": "元数据锁(MDL)详解 (作用、规则、长事务影响)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁"
    ],
    "difficulty": "Medium",
    "title": "意向锁(IS/IX)详解 (作用、兼容性)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁",
      "Replication",
      "主从复制",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Hard",
    "title": "AUTO-INC锁与innodb_autoinc_lock_mode详解"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁",
      "Deadlock",
      "死锁"
    ],
    "difficulty": "Hard",
    "title": "分析update/insert导致的死锁 (字节面试题)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Locking",
      "锁",
      "Index",
      "索引",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "update无索引导致锁全表分析及避免方法"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Logging",
      "日志",
      "Transaction",
      "事务",
      "Query Processing",
      "查询处理"
    ],
    "difficulty": "Medium",
    "title": "MySQL update语句执行流程 (含日志)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Logging",
      "日志",
      "Transaction",
      "事务",
      "MVCC",
      "MVCC"
    ],
    "difficulty": "Medium",
    "title": "undo log的作用 (原子性, MVCC)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Logging",
      "日志",
      "Transaction",
      "事务",
      "Crash Recovery",
      "崩溃恢复",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "redo log的作用 (持久性, 崩溃恢复, 性能)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Logging",
      "日志",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "WAL技术详解"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Logging",
      "日志",
      "Transaction",
      "事务"
    ],
    "difficulty": "Medium",
    "title": "redo log与undo log的区别"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Logging",
      "日志",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "redo log刷盘时机与策略 (innodb_flush_log_at_trx_commit)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Logging",
      "日志"
    ],
    "difficulty": "Medium",
    "title": "redo log循环写入与checkpoint机制"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Logging",
      "日志",
      "Replication",
      "主从复制",
      "Backup",
      "备份"
    ],
    "difficulty": "Medium",
    "title": "binlog的作用与格式详解"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Logging",
      "日志"
    ],
    "difficulty": "Medium",
    "title": "redo log与binlog的区别"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Replication",
      "主从复制",
      "Logging",
      "日志"
    ],
    "difficulty": "Medium",
    "title": "MySQL主从复制原理与模型"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Logging",
      "日志",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "binlog刷盘时机与策略 (sync_binlog)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Logging",
      "日志",
      "Transaction",
      "事务",
      "Consistency",
      "一致性"
    ],
    "difficulty": "Medium",
    "title": "两阶段提交的必要性 (redo log与binlog一致性)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Logging",
      "日志",
      "Transaction",
      "事务"
    ],
    "difficulty": "Hard",
    "title": "MySQL两阶段提交过程详解"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Logging",
      "日志",
      "Transaction",
      "事务",
      "Crash Recovery",
      "崩溃恢复"
    ],
    "difficulty": "Hard",
    "title": "两阶段提交异常恢复机制"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Logging",
      "日志",
      "Transaction",
      "事务",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Hard",
    "title": "MySQL组提交机制详解及其对两阶段提交的优化"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Logging",
      "日志",
      "Performance",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "优化MySQL磁盘I/O (日志刷盘策略)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Transaction",
      "事务"
    ],
    "difficulty": "Easy",
    "title": "事务的ACID特性"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "Transaction",
      "事务",
      "Logging",
      "日志",
      "MVCC",
      "MVCC",
      "Locking",
      "锁"
    ],
    "difficulty": "Medium",
    "title": "InnoDB如何保证ACID特性"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Transaction",
      "事务",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "并发事务的问题 (脏读、不可重复读、幻读)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Transaction",
      "事务",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "事务隔离级别详解及其解决的问题"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "Transaction",
      "事务",
      "Phantom Read",
      "幻读",
      "MVCC",
      "MVCC",
      "Locking",
      "锁"
    ],
    "difficulty": "Medium",
    "title": "MySQL默认隔离级别及幻读避免机制"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "MVCC",
      "MVCC",
      "Transaction",
      "事务"
    ],
    "difficulty": "Medium",
    "title": "Read View结构与作用"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "InnoDB",
      "InnoDB",
      "MVCC",
      "MVCC",
      "Storage",
      "存储结构"
    ],
    "difficulty": "Medium",
    "title": "记录中的事务隐藏列 (trx_id, roll_pointer)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "MVCC",
      "MVCC",
      "Transaction",
      "事务"
    ],
    "difficulty": "Hard",
    "title": "MVCC可见性判断规则与版本链"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "MVCC",
      "MVCC",
      "Transaction",
      "事务"
    ],
    "difficulty": "Hard",
    "title": "可重复读与读提交隔离级别的实现原理 (Read View)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Transaction",
      "事务",
      "MVCC",
      "MVCC",
      "Phantom Read",
      "幻读"
    ],
    "difficulty": "Medium",
    "title": "MVCC如何避免幻读 (快照读)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Transaction",
      "事务",
      "Locking",
      "锁",
      "Phantom Read",
      "幻读"
    ],
    "difficulty": "Medium",
    "title": "Next-Key Lock如何避免幻读 (当前读)"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Transaction",
      "事务",
      "Phantom Read",
      "幻读",
      "MVCC",
      "MVCC",
      "Locking",
      "锁"
    ],
    "difficulty": "Hard",
    "title": "可重复读隔离级别下的幻读问题及场景分析"
  },
  {
    "type": "Question",
    "category": [
      "General",
      "通用",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Medium",
    "title": "八股文"
  }
]