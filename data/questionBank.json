[
  {
    "type": "Coding",
    "title": "接雨水",
    "category": [
      "LeetCode",
      "Array",
      "Dynamic Programming",
      "Stack",
      "Two Pointers"
    ],
    "difficulty": "Hard"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "Data Structures",
      "数据结构",
      "Redis"
    ],
    "difficulty": "Medium",
    "title": "ZSET表的原理，怎么实现的用户登录限流，表占用过大时是手动还是自动删除数据，占用上限是如何设置的"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络"
    ],
    "difficulty": "Hard",
    "title": "Epoll的原理"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Tree",
      "树"
    ],
    "difficulty": "Hard",
    "title": "红黑树的原理，在Epoll中红黑树的键值分别是什么"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络"
    ],
    "difficulty": "Hard",
    "title": "epoll_wait返回的队列是由谁将事件加入队列的"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池有几个分别是什么作用"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "Linux中的硬连接和软连接，硬连接软连接可以比作哪些智能指针"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "虚拟内存，不同操作系统下页表是几级"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "中断机制是怎么处理的"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "Dynamic Programming",
      "动态规划",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "最长公共子序列"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "String",
      "字符串",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "无重复最长子串"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "UDP"
    ],
    "difficulty": "Medium",
    "title": "TCP和UDP的区别"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "Array",
      "数组",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "区间合并"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Golang",
      "Go"
    ],
    "difficulty": "Medium",
    "title": "进程线程协程，gmp调度？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "乐观锁和悲观锁？讲讲怎么实现？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "死锁的条件？解决办法？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "MySQL事务特性以及实现"
  },
  {
    "type": "Question",
    "category": [
      "System Design",
      "系统设计"
    ],
    "difficulty": "Hard",
    "title": "如果你的项目有千万级的用户量，你怎么优化"
  },
  {
    "type": "Question",
    "category": [
      "Design Patterns",
      "设计模式"
    ],
    "difficulty": "Easy",
    "title": "设计模式了解过哪些"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "Graph",
      "图",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "岛屿数量"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "UDP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "TCP和UDP区别，HTTP用的谁，为什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "HTTP状态码"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "TCP",
      "UDP"
    ],
    "difficulty": "Medium",
    "title": "HTTP是长连接还是短连接，如何用UDP实现"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "MySQL索引如何实现的。"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "MySQL索引为什么用B+不用B树？如果把内容存在内存上，用B树会不会快一点。"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "分库分表的常用中间件有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Hard",
    "title": "有哪些问题中间件无法提供帮助、只能改写业务代码的场景？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "MySQL",
      "分库分表"
    ],
    "difficulty": "Easy",
    "title": "分库分表使用了什么中间件？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Medium",
    "title": "分库分表的实现场景和方式有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Medium",
    "title": "分表之后，要查询两个表的数据要怎么查？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Medium",
    "title": "分库分表的优缺点是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Hard",
    "title": "分库分表业界有哪些替代方案？（提示：分布式文件系统，因为分库分表会出现降低QPS，比如range查询失效）"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Hard",
    "title": "为什么做了分库分表后分页比较困难了？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Hard",
    "title": "如果10亿数据要分表，要怎么分？业务怎么切？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "Concurrency",
      "并发",
      "分库分表"
    ],
    "difficulty": "Hard",
    "title": "分库分表怎么保证数据一致性？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Medium",
    "title": "分库分表选的什么分片键？什么分片算法？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Medium",
    "title": "分库分表后的分布式ID怎么做？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Concurrency",
      "并发",
      "动态代理"
    ],
    "difficulty": "Medium",
    "title": "JDK和Cglib动态代理有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Array",
      "数组",
      "Linked List",
      "链表",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "ArrayList和LinkedList的区别？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Hash Table",
      "哈希表",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "HashMap原理?"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Tree",
      "树",
      "Binary Search Tree",
      "二叉搜索树",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "红黑树红和黑代表什么?"
  },
  {
    "type": "Coding",
    "category": [
      "Data Structures",
      "数据结构",
      "Hash Table",
      "哈希表",
      "Array",
      "数组",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "HashMap数组索引怎么确认？"
  },
  {
    "type": "Question",
    "category": [
      "Algorithms",
      "算法",
      "Hash Table",
      "哈希表",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "常见的哈希算法了解哪些？解决哈希冲突的方法?"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "Java有什么集合容器？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Tree",
      "树",
      "Sorting",
      "排序",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "Treemap怎么排序，有什么注意事项，可不可以自定义排序，排序的数据结构是什么"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Concurrency",
      "并发",
      "Array",
      "数组",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "CopyOnWriteArrayList怎么保证线程安全，优点是这个，那缺点呢？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Concurrency",
      "并发",
      "Array",
      "数组",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "ArrayList线程安全吗，想要使用线程安全的ArrayList怎么办？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Hash Table",
      "哈希表",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "假设你要遍历一个 HashMap，同时删除一些 key，应该怎么编写代码？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Concurrency",
      "并发",
      "Hash Table",
      "哈希表",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "HashTable怎么保证线程安全的，ConcurrentHashMap呢，怎么去选择呢"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Hash Table",
      "哈希表",
      "Tree",
      "树",
      "Binary Search Tree",
      "二叉搜索树",
      "Java"
    ],
    "difficulty": "Hard",
    "title": "Hashmap 为什么选择红黑树而不是AVL"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Reflection",
      "反射"
    ],
    "difficulty": "Medium",
    "title": "你对Java的反射如何理解的，原理是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Reflection",
      "反射"
    ],
    "difficulty": "Medium",
    "title": "反射机制对于其他没有反射的语言有什么好处？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Reflection",
      "反射"
    ],
    "difficulty": "Medium",
    "title": "Java中哪些效率高的功能是基于反射做的呢？"
  },
  {
    "type": "Question",
    "category": [
      "String",
      "字符串",
      "Java",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "byte怎么转字符串？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Reflection",
      "反射"
    ],
    "difficulty": "Medium",
    "title": "反射的应用场景"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Reflection",
      "反射"
    ],
    "difficulty": "Medium",
    "title": "反射为什么性能开销高"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "volatile 关键字的作用是什么？不加这个关键字对变量修改就不会加到主存吗？加了这个关键字还需要加锁吗？这个关键字的一些应用场景都有哪些呢？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池",
      "Java"
    ],
    "difficulty": "Hard",
    "title": "假设让你写一个线程池工具，你觉得应该怎么去设计呢？应该有什么变量？有什么接口？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "比如核心线程数量是5，最大线程是10，现在来了11个任务，怎么调度？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "线程池的执行流程?"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "线程池是否会出现并发安全问题?"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "动态线程池是怎么实现的？动态调整机制是什么？我们应该设置多少核心线程数和最大线程数，以及通过哪里去设置？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "动态线程池的“动态”体现在什么地方？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池过程和原理"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "你怎么实际计算需要的核心线程数目和阻塞队列大小?你怎么设定拒绝策略?高请求下有的用户的请求被拒绝了，你会怎么处理反映给用户?"
  },
  {
    "type": "Question",
    "category": [
      "String",
      "字符串",
      "Java",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "String，StringBuilder，StringBuffer的区别?"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "synchronized和reentrantlock的区别？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "java乐观锁和悲观锁？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "Java 有哪些重要的锁？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Hard",
    "title": "AQS实现"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "有了synchornized为什么还会出现lock"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Operating System",
      "操作系统",
      "多线程",
      "Multi Threading"
    ],
    "difficulty": "Medium",
    "title": "多进程、多线程、多协程各自的优势和劣势？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "多线程",
      "Multi Threading"
    ],
    "difficulty": "Easy",
    "title": "Java有哪些线程状态？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Operating System",
      "操作系统",
      "Java",
      "Multi Threading"
    ],
    "difficulty": "Medium",
    "title": "如果一个进程创建了几万个线程会出现什么问题？"
  },
  {
    "type": "Coding",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Multi Threading",
      "多线程"
    ],
    "difficulty": "Medium",
    "title": "怎么让两个线程有序执行？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "多线程如何做同步"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "线程的上下文切换需要切换什么东西"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "completablefuture 和 futuretask"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "Java线程怎么进入阻塞状态"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "Java线程怎么进入Runnable状态"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Operating System",
      "操作系统",
      "Java"
    ],
    "difficulty": "Hard",
    "title": "Java线程上下文切换具体过程"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Medium",
    "title": "如果让你调研是否要从Java 8升级到更新的版本（如11或17），你会如何评估其必要性？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Medium",
    "title": "BigDecimal怎么存储，怎么计算，有什么注意事项，为什么他能保证不丢失"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Design Patterns",
      "设计模式"
    ],
    "difficulty": "Medium",
    "title": "JDK Proxy 和 CGLib Proxy 的区别"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Easy",
    "title": "Java中你遇到过哪些异常？你分别怎么处理？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Medium",
    "title": "团队升级JDK版本的话你怎么调研？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Hard",
    "title": "Java分配大对象怎么进行性能优化"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Generics",
      "泛型"
    ],
    "difficulty": "Medium",
    "title": "泛型、反射和类型推断的关系"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Algorithms",
      "算法",
      "前端",
      "Front End"
    ],
    "difficulty": "Easy",
    "title": "前端常见的数据结构有哪些？有什么基础算法？有什么应用场景？"
  },
  {
    "type": "Question",
    "category": [
      "Algorithms",
      "算法"
    ],
    "difficulty": "Easy",
    "title": "什么是时间复杂度？"
  },
  {
    "type": "Question",
    "category": [
      "Algorithms",
      "算法"
    ],
    "difficulty": "Easy",
    "title": "什么是空间复杂度？"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "两数之和"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "买卖股票的最佳时机"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "盛水最多的容器"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "除自身以外数组的乘积"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "无重复字符的最长子串"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Easy",
    "title": "验证回文串"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "反转字符串中的单词"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "手写深拷贝"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Easy",
    "title": "手写 getType 函数"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 class 继承"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "使用 ES6 语法写出三种菜单的 class"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写防抖 Debounce"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写截流 Throttle"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 bind"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 call 和 apply"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 EventBus 自定义事件"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写数组拍平 Array Flatten"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写解析 URL 参数为 JS 对象"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法"
    ],
    "difficulty": "Easy",
    "title": "手写数组去重"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法"
    ],
    "difficulty": "Medium",
    "title": "手写红绿灯"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Hard",
    "title": "手写 Promise"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Hard",
    "title": "手写 Promise.all"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Hard",
    "title": "手写 Promise.race"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Hard",
    "title": "手写 Promise.allSettled"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Hard",
    "title": "手写一个 LazyMan 实现 sleep 机制"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 curry 函数，实现函数柯里化"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 compose 函数"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "Data Structures",
      "数据结构",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "手写一个 LRU 缓存"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End",
      "Vue"
    ],
    "difficulty": "Medium",
    "title": "使用 Vue3 Composable 组合式函数，实现 useCount"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End",
      "Vue"
    ],
    "difficulty": "Medium",
    "title": "使用 Vue3 Composable 组合式函数，实现 useRequest"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End",
      "React"
    ],
    "difficulty": "Medium",
    "title": "使用 React Hook 实现 useCount"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End",
      "React"
    ],
    "difficulty": "Medium",
    "title": "使用 React Hook 实现 useRequest"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "进程和线程的区别"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "进程间的通信"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "单核 CPU 如何实现并发"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "CPU 调度算法有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Linux"
    ],
    "difficulty": "Medium",
    "title": "linux 如何查找你的进程占用的那个端口"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "单核服务器连接数超载了怎么办"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题",
      "Operating System",
      "操作系统",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "请简述一个编译器的执行过程。前端有哪些常见的编译工具？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题"
    ],
    "difficulty": "Medium",
    "title": "什么是编译型语言和解释型语言，他们有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "String",
      "字符串",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "简述 JS 垃圾回收的过程。用什么算法？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "什么是内存泄漏？如何排查？JS 内存泄漏的常见原因？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "简述 JS 运行时的堆栈内存模型？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题"
    ],
    "difficulty": "Medium",
    "title": "冯·诺依曼架构是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题"
    ],
    "difficulty": "Medium",
    "title": "计算机内部为何使用二进制？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题"
    ],
    "difficulty": "Medium",
    "title": "二进制如何表示负数和小数？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "什么是虚拟内存，为何要使用虚拟内存？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题"
    ],
    "difficulty": "Medium",
    "title": "什么是 Unicode 编码？它和常见的 UTF-8 有什么关系？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络"
    ],
    "difficulty": "Medium",
    "title": "简述计算机网络的 OSI 模型"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络"
    ],
    "difficulty": "Easy",
    "title": "一个域名对应一个 ip 吗"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络"
    ],
    "difficulty": "Medium",
    "title": "UDP 和 TCP 协议的区别？有什么应用场景"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Array",
      "数组",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "数组和链表有什么区别？从内存结构上来说"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "进程和线程的区别"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "进程间的通信"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "单核 CPU 如何实现并发"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "CPU 调度算法有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "linux 如何查找你的进程占用的那个端口"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "单核服务器连接数超载了怎么办"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "请简述一个编译器的执行过程。前端有哪些常见的编译工具？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "什么是编译型语言和解释型语言，他们有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "简述 JS 垃圾回收的过程。用什么算法？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "什么是内存泄漏？如何排查？JS 内存泄漏的常见原因？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Basic Concepts",
      "基本概念"
    ],
    "difficulty": "Easy",
    "title": "DOCTYPE 是什么，都有哪些属性？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Meta",
      "元数据"
    ],
    "difficulty": "Easy",
    "title": "meta 标签是干什么的，都有什么属性和作用"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "DOM",
      "文档对象模型"
    ],
    "difficulty": "Easy",
    "title": "什么是 DOM ，它和 HTML 有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Semantic HTML",
      "语义化HTML"
    ],
    "difficulty": "Medium",
    "title": "如何理解 HTML5 语义化 ？有哪些常见的语义化标签？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "DOM",
      "文档对象模型",
      "Attributes vs Properties"
    ],
    "difficulty": "Medium",
    "title": "DOM 节点的 attr 和 property 有何区别"
  },
  {
    "type": "Coding",
    "category": [
      "HTML",
      "HTML",
      "DOM Manipulation",
      "DOM操作"
    ],
    "difficulty": "Medium",
    "title": "如何一次性插入多个 DOM 节点？考虑性能"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "DOM",
      "文档对象模型",
      "Dimensions"
    ],
    "difficulty": "Easy",
    "title": "offsetHeight scrollHeight clientHeight 有什么区别"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "DOM",
      "文档对象模型",
      "Collections"
    ],
    "difficulty": "Medium",
    "title": "HTMLCollection 和 NodeList 的区别"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "DOM",
      "文档对象模型",
      "Nodes"
    ],
    "difficulty": "Easy",
    "title": "Node 和 Element 有什么区别？"
  },
  {
    "type": "Coding",
    "category": [
      "HTML",
      "HTML",
      "Event Handling",
      "事件处理"
    ],
    "difficulty": "Medium",
    "title": "开发一个无限下拉加载图片的页面，如何给每个图片绑定 click 事件？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Event Handling",
      "事件处理",
      "Loading"
    ],
    "difficulty": "Easy",
    "title": "window.onload 和 DOMContentLoaded 的区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Performance",
      "性能",
      "Script Loading"
    ],
    "difficulty": "Medium",
    "title": "script 标签放在 head 里，怎么解决加载阻塞的问题"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Basic Concepts",
      "基本概念",
      "Inline vs Block"
    ],
    "difficulty": "Easy",
    "title": "常见的 HTML 标签哪些是 inline 元素，哪些是 block 元素，哪些是 inline-block 元素"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Selectors",
      "选择器"
    ],
    "difficulty": "Easy",
    "title": "常见的 CSS 选择器有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Box Model",
      "盒子模型"
    ],
    "difficulty": "Medium",
    "title": "CSS 盒子模型，尺寸计算"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "Margin Collapse"
    ],
    "difficulty": "Medium",
    "title": "margin 纵向重叠"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Text Styling",
      "文本样式",
      "Inheritance"
    ],
    "difficulty": "Easy",
    "title": "lineHeight 如何继承？"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "Negative Margin"
    ],
    "difficulty": "Medium",
    "title": "margin 负值问题"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "BFC"
    ],
    "difficulty": "Medium",
    "title": "什么是 BFC 如何触发 BFC？"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "Centering"
    ],
    "difficulty": "Medium",
    "title": "使用 CSS 实现居中对齐，有哪几种方式？"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Positioning",
      "定位",
      "Positioning Context"
    ],
    "difficulty": "Medium",
    "title": "什么是 CSS 定位上下文？absolute 和 relative 分别依据谁来定位？"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Visibility",
      "可见性"
    ],
    "difficulty": "Easy",
    "title": "CSS overflow: hidden display：none 和 visibility: hidden 有什么区别"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Units",
      "单位"
    ],
    "difficulty": "Easy",
    "title": "CSS px % em rem vw/vh 的区别"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "UI",
      "Retina"
    ],
    "difficulty": "Medium",
    "title": "如何实现 Retina 屏 1px 像素边框"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "UI",
      "Triangle"
    ],
    "difficulty": "Easy",
    "title": "使用 CSS 画一个三角形"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "UI",
      "Theme"
    ],
    "difficulty": "Medium",
    "title": "如何实现黑白主题变化？"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "Responsive Design"
    ],
    "difficulty": "Medium",
    "title": "如何实现响应式布局？"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Z-index"
    ],
    "difficulty": "Easy",
    "title": "如何理解 z-index ？"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "Flexbox"
    ],
    "difficulty": "Hard",
    "title": "使用 flex 设计一个“四合院”布局"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Tools",
      "工具",
      "Frameworks",
      "预处理器"
    ],
    "difficulty": "Medium",
    "title": "你用过哪些 CSS 相关的技术，如库、框架、预处理语言、后处理语言等"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Easy",
    "title": "TS 优缺点，使用场景"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Easy",
    "title": "TS 基础类型有哪些"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Array",
      "数组",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Easy",
    "title": "数组 Array 和元组 Tuple 的区别是什么"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Easy",
    "title": "枚举 enum 是什么？有什么使用场景？"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "keyof 和 typeof 有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "any void never unknown 有什么区别"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "unknown 和 any 区别"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "TS 访问修饰符 public protected private 有什么作用"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "type 和 interface 共同和区别，如何选择"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "什么是泛型，如何使用它？"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "什么是交叉类型和联合类型"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "是否用过工具类型"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "TS 这些符号 ? ?. ?? ! _ & | # 分别什么意思"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "什么是抽象类 abstract class"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Hard",
    "title": "如何扩展 window 属性，如何定义第三方模块的类型"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Experience",
      "经验"
    ],
    "difficulty": "Medium",
    "title": "是否有过真实的 Typescript 开发经验，讲一下你的使用体验"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "TCP 是如何建立连接的，三次握手，四次挥手"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "HTTP 几个版本的区别"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "HTTP 常见的状态码"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "HTTP 常见 Header"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "URL 包含哪些部分？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "GET 和 POST 请求的区别"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "Ajax Fetch Axios 三者有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "Fetch 和 XMLHTTPRequest 有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "什么是 Restful API ？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "什么是 GraphQL ？"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Hash Table",
      "哈希表"
    ],
    "difficulty": "Easy",
    "title": "1. 两数之和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "String",
      "字符串"
    ],
    "difficulty": "Medium",
    "title": "49. 字母异位词分组"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "128. 最长连续序列"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Two Pointers",
      "双指针"
    ],
    "difficulty": "Easy",
    "title": "283. 移动零"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "11. 盛最多水的容器"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "15. 三数之和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Hard",
    "title": "42. 接雨水"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "String",
      "字符串",
      "Sliding Window",
      "滑动窗口"
    ],
    "difficulty": "Medium",
    "title": "3. 无重复字符的最长子串"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "String",
      "字符串"
    ],
    "difficulty": "Medium",
    "title": "438. 找到字符串中所有字母异位词"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "560. 和为 K 的子数组"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Sliding Window",
      "滑动窗口"
    ],
    "difficulty": "Hard",
    "title": "239. 滑动窗口最大值"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "String",
      "字符串",
      "Sliding Window",
      "滑动窗口"
    ],
    "difficulty": "Hard",
    "title": "76. 最小覆盖子串"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "53. 最大子数组和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "56. 合并区间"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "189. 轮转数组"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "238. 除自身以外数组的乘积"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Hard",
    "title": "41. 缺失的第一个正数"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Matrix",
      "矩阵"
    ],
    "difficulty": "Medium",
    "title": "73. 矩阵置零"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Matrix",
      "矩阵"
    ],
    "difficulty": "Medium",
    "title": "54. 螺旋矩阵"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Matrix",
      "矩阵"
    ],
    "difficulty": "Medium",
    "title": "48. 旋转图像"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Matrix",
      "矩阵"
    ],
    "difficulty": "Medium",
    "title": "240. 搜索二维矩阵 II"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "160. 相交链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "206. 反转链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "234. 回文链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "141. 环形链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Medium",
    "title": "142. 环形链表 II"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "21. 合并两个有序链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Medium",
    "title": "2. 两数相加"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Medium",
    "title": "19. 删除链表的倒数第 N 个结点"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Medium",
    "title": "24. 两两交换链表中的节点"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Hard",
    "title": "25. K 个一组翻转链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Medium",
    "title": "138. 随机链表的复制"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表",
      "Sorting",
      "排序"
    ],
    "difficulty": "Medium",
    "title": "148. 排序链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Hard",
    "title": "23. 合并 K 个升序链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Medium",
    "title": "146. LRU 缓存"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Easy",
    "title": "94. 二叉树的中序遍历"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Easy",
    "title": "104. 二叉树的最大深度"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Easy",
    "title": "226. 翻转二叉树"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Easy",
    "title": "101. 对称二叉树"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Easy",
    "title": "543. 二叉树的直径"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "102. 二叉树的层序遍历"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树",
      "Binary Search Tree",
      "二叉搜索树"
    ],
    "difficulty": "Easy",
    "title": "108. 将有序数组转换为二叉搜索树"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树",
      "Binary Search Tree",
      "二叉搜索树"
    ],
    "difficulty": "Medium",
    "title": "98. 验证二叉搜索树"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树",
      "Binary Search Tree",
      "二叉搜索树"
    ],
    "difficulty": "Medium",
    "title": "230. 二叉搜索树中第 K 小的元素"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "199. 二叉树的右视图"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "114. 二叉树展开为链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "105. 从前序与中序遍历序列构造二叉树"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "437. 路径总和 III"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "236. 二叉树的最近公共祖先"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Hard",
    "title": "124. 二叉树中的最大路径和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Graph",
      "图"
    ],
    "difficulty": "Medium",
    "title": "200. 岛屿数量"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Graph",
      "图"
    ],
    "difficulty": "Medium",
    "title": "994. 腐烂的橘子"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Graph",
      "图"
    ],
    "difficulty": "Medium",
    "title": "207. 课程表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Trie",
      "前缀树"
    ],
    "difficulty": "Medium",
    "title": "208. 实现 Trie (前缀树)"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "46. 全排列"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "78. 子集"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "17. 电话号码的字母组合"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "39. 组合总和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "22. 括号生成"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "79. 单词搜索"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "131. 分割回文串"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Hard",
    "title": "51. N 皇后"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找"
    ],
    "difficulty": "Easy",
    "title": "35. 搜索插入位置"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找",
      "Matrix",
      "矩阵"
    ],
    "difficulty": "Medium",
    "title": "74. 搜索二维矩阵"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找"
    ],
    "difficulty": "Medium",
    "title": "34. 在排序数组中查找元素的第一个和最后一个位置"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找"
    ],
    "difficulty": "Medium",
    "title": "33. 搜索旋转排序数组"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找"
    ],
    "difficulty": "Medium",
    "title": "153. 寻找旋转排序数组中的最小值"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找"
    ],
    "difficulty": "Hard",
    "title": "4. 寻找两个正序数组的中位数"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Stack",
      "栈"
    ],
    "difficulty": "Easy",
    "title": "20. 有效的括号"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Stack",
      "栈"
    ],
    "difficulty": "Medium",
    "title": "155. 最小栈"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Stack",
      "栈",
      "String",
      "字符串"
    ],
    "difficulty": "Medium",
    "title": "394. 字符串解码"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Stack",
      "栈"
    ],
    "difficulty": "Medium",
    "title": "739. 每日温度"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Stack",
      "栈"
    ],
    "difficulty": "Hard",
    "title": "84. 柱状图中最大的矩形"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Heap",
      "堆"
    ],
    "difficulty": "Medium",
    "title": "215. 数组中的第K个最大元素"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Heap",
      "堆",
      "Hash Table",
      "哈希表"
    ],
    "difficulty": "Medium",
    "title": "347. 前 K 个高频元素"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Heap",
      "堆",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Hard",
    "title": "295. 数据流的中位数"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Greedy",
      "贪心算法"
    ],
    "difficulty": "Easy",
    "title": "121. 买卖股票的最佳时机"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Greedy",
      "贪心算法"
    ],
    "difficulty": "Medium",
    "title": "55. 跳跃游戏"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Greedy",
      "贪心算法"
    ],
    "difficulty": "Medium",
    "title": "45. 跳跃游戏 II"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Greedy",
      "贪心算法"
    ],
    "difficulty": "Medium",
    "title": "763. 划分字母区间"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Easy",
    "title": "70. 爬楼梯"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Easy",
    "title": "118. 杨辉三角"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "198. 打家劫舍"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "279. 完全平方数"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "322. 零钱兑换"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "139. 单词拆分"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "300. 最长递增子序列"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "152. 乘积最大子数组"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "416. 分割等和子集"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Hard",
    "title": "32. 最长有效括号"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "62. 不同路径"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "64. 最小路径和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划",
      "String",
      "字符串"
    ],
    "difficulty": "Medium",
    "title": "5. 最长回文子串"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "1143. 最长公共子序列"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "72. 编辑距离"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Bit Manipulation",
      "位运算"
    ],
    "difficulty": "Easy",
    "title": "136. 只出现一次的数字"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Easy",
    "title": "169. 多数元素"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Sorting",
      "排序"
    ],
    "difficulty": "Medium",
    "title": "75. 颜色分类"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "31. 下一个排列"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "287. 寻找重复数"
  },
  {
    "type": "Coding",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "Java两个线程交叉打印"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MQ"
    ],
    "difficulty": "Medium",
    "title": "为什么使用消息队列？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MQ"
    ],
    "difficulty": "Medium",
    "title": "消息队列有什么优点和缺点？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "MQ",
      "Kafka",
      "RocketMQ"
    ],
    "difficulty": "Hard",
    "title": "Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么区别，以及适合哪些场景？"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "2610. 转换二维数组"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ThreadPoolExecutor",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "Java线程池 ThreadPoolExecutor 为什么要使用高位存储runState"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Serialization",
      "序列化"
    ],
    "difficulty": "Medium",
    "title": "Serialize 接口的作用是什么？serialVersionUID 呢？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "简单讲一下线程池"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "线程池的拒绝策略大概有几种?"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "线程池的池化思想还被用在哪里?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Spring",
      "Spring"
    ],
    "difficulty": "Medium",
    "title": "spring最核心的是什么?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Spring",
      "Spring"
    ],
    "difficulty": "Medium",
    "title": "简单讲一下你对IOC的理解?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Spring",
      "Spring"
    ],
    "difficulty": "Medium",
    "title": "spring生成的bean和直接new的对象有什么区别?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Spring",
      "Spring",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Hard",
    "title": "spring的bean是线程安全的吗?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Spring",
      "Spring"
    ],
    "difficulty": "Medium",
    "title": "讲一下springMVC最核心的是什么?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Spring",
      "Spring"
    ],
    "difficulty": "Medium",
    "title": "是怎么解析url的?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Spring",
      "Spring"
    ],
    "difficulty": "Medium",
    "title": "实现springMVC最核心的几个类是什么?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "mysql的在innodb存储引擎下数据是怎么组织的?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "索引和数据是放在一起的吗?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Tree",
      "树"
    ],
    "difficulty": "Medium",
    "title": "讲一下b+树"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Tree",
      "树"
    ],
    "difficulty": "Medium",
    "title": "b+树在非叶子结点不存储数据相比于b树有什么优势?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Algorithms",
      "算法"
    ],
    "difficulty": "Medium",
    "title": "为什么加索引能提升查询速度?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Algorithms",
      "算法"
    ],
    "difficulty": "Hard",
    "title": "b+树o(lg n)是怎么得出来的?底数是多少?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Tree",
      "树"
    ],
    "difficulty": "Hard",
    "title": "b+树的k叉树这个k最大是多少?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "mysql的数据写经历了哪些过程?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "mysql中有哪几种log?简单答一下各自的作用?"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "了解mysql的MVCC吗?核心的是什么?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "JVM",
      "JVM"
    ],
    "difficulty": "Medium",
    "title": "jvm的内存结构?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "JVM",
      "JVM",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "哪些是线程私有的?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "JVM",
      "JVM"
    ],
    "difficulty": "Easy",
    "title": "代码文件(.java文件)是放在哪里的?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "JVM",
      "JVM",
      "Algorithms",
      "算法"
    ],
    "difficulty": "Hard",
    "title": "如何理解\"尽量将递归转为迭代\",结合jvm讲一下?"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池是什么？为什么使用线程池？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "线程池的原理是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "Java 线程池的参数有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的类型有哪些？分别适用于什么场景？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的拒绝策略有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何监控线程池的状态？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "使用无界队列的线程池会导致内存飙升吗？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何合理配置线程池的大小？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的execute()和submit()方法有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何优雅地关闭线程池？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的创建方式有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "`ThreadPoolExecutor` 的核心参数有哪些，它们的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "线程池是如何管理线程的生命周期的？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的饱和策略有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "什么是线程池的“预热”？如何实现？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何动态调整线程池的参数？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "在使用线程池时，如何避免死锁？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何选择合适的 `BlockingQueue`？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "`Future`接口的作用是什么？如何使用它来获取线程池任务的执行结果？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在使用线程池时，如何处理任务中抛出的异常？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的监控指标有哪些？如何通过 JMX 监控线程池？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "除了 `ThreadPoolExecutor`，还有其他的线程池实现吗？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "`ForkJoinPool` 和 `ThreadPoolExecutor` 有什么区别？分别适用于什么场景？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "什么是 `CompletableFuture`？它和线程池有什么关系？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何使用线程池来执行定时任务？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在 Spring 框架中，如何配置和使用线程池？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的 execute() 和 submit() 方法有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "ThreadPoolExecutor 的核心参数有哪些，它们的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何选择合适的 BlockingQueue？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "Future 接口的作用是什么？如何使用它来获取线程池任务的执行结果？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "ThreadPoolExecutor 中，任务是如何从 workQueue 中被取出的？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "ThreadPoolExecutor 中，addWorker 方法的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "分析 ThreadPoolExecutor 的状态转换过程。"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的 allowCoreThreadTimeOut 参数有什么作用？在什么情况下应该使用它？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的 prestartAllCoreThreads() 方法有什么作用？它和线程池的预热有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "除了 ThreadPoolExecutor，还有其他的线程池实现吗？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "ForkJoinPool 和 ThreadPoolExecutor 有什么区别？分别适用于什么场景？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "什么是 CompletableFuture？它和线程池有什么关系？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "ForkJoinPool 的工作窃取 (Work-Stealing) 算法是如何实现的？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "什么是反应式编程 (Reactive Programming)？它和线程池有什么关系？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "什么是虚拟线程 (Virtual Threads, Project Loom)？它和线程池有什么区别和优势？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "CompletionService 是什么？它解决了什么问题？如何使用它来提高线程池的利用率？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何使用 ExecutorService.invokeAll() 方法来批量执行任务？它和 ExecutorService.submit() 有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "如何使用 CompletableFuture 来构建异步管道？它和传统的线程池有什么优势？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "如何使用 Java 9 引入的 Flow API 来实现响应式编程？它和线程池有什么关系？"
  },
  {
    "type": "Coding",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何设计一个线程池，满足特定的性能指标（例如：吞吐量、延迟）"
  },
  {
    "type": "Coding",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何实现一个自定义的拒绝策略？"
  },
  {
    "type": "Coding",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何实现一个自定义的 ThreadFactory？为什么要自定义 ThreadFactory？"
  },
  {
    "type": "Coding",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "如何在线程池中实现任务的优先级调度？"
  },
  {
    "type": "Coding",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何保证提交到线程池的任务的执行顺序？"
  },
  {
    "type": "Coding",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "如何设计一个可伸缩的线程池？"
  },
  {
    "type": "Coding",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如果线程池中的线程因为异常而终止，如何自动重启线程？"
  },
  {
    "type": "Coding",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何实现一个线程池的优雅降级方案？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何避免死锁？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在什么情况下适合使用 CachedThreadPool？它的缺点是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "如何排查线程池中的线程死锁问题？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何避免线程池中的线程饥饿问题？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如果线程池的任务执行时间不稳定，如何优化线程池的配置？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "在高并发场景下，如何避免线程池成为性能瓶颈？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "你在实际项目中使用线程池遇到过什么问题？你是如何解决的？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何使用 Java Flight Recorder (JFR) 分析线程池的性能问题？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何避免在 Runnable 或 Callable 中抛出未捕获的异常？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何使用 APM (Application Performance Monitoring) 工具来监控线程池的性能？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何根据线程池的监控数据进行调优？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何使用压力测试工具来评估线程池的性能？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在使用线程池时，如何保证线程安全？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "volatile 关键字在线程池中有什么应用？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "AtomicInteger 等原子类在线程池中有什么作用？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何使用 CountDownLatch、CyclicBarrier、Semaphore 等并发工具来协调线程池中的任务？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "Exchanger 在线程池中有什么应用？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何使用 Phaser 来管理线程池中的阶段性任务？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何避免在线程池中使用过多的 synchronized 关键字？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的线程上下文切换是如何发生的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池的线程调度算法是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "Java 内存模型 (JMM) 在线程池中扮演什么角色？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Thread Pool",
      "线程池",
      "Design Pattern",
      "设计模式"
    ],
    "difficulty": "Medium",
    "title": "线程池是否体现了某种设计模式？如果是，是什么模式？请描述该模式的意图和如何在线程池中体现。"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在高并发订单场景中，如何使用线程池来优化性能？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在处理大数据任务时，如何使用线程池来并行处理数据？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在处理 I/O 密集型任务时，如何选择合适的线程池配置？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在微服务架构中，如何管理和监控各个服务的线程池？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "请分享一个你曾经遇到的线程池相关的性能问题，你是如何分析和解决的？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "请分析一个开源项目中的线程池使用方式，并指出其优点和缺点。"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "你有什么关于线程池使用的经验或者教训可以分享？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "在 Spring 中，如何配置和使用 ThreadPoolTaskExecutor？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "Spring 的 @Async 注解是如何工作的？它和线程池有什么关系？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何在 Spring Boot 应用中监控和管理线程池？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Concurrency",
      "并发",
      "ThreadPool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "如何在 Spring Cloud 应用中使用线程池来实现服务间的异步调用？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 的基本原理是什么？它是如何实现同步的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 中的同步状态（state）有哪些用途？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 的公平锁和非公平锁有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 中的 ConditionObject 是什么？它有什么作用？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 的 acquire 和 release 流程是怎样的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 如何支持共享模式和独占模式？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Data Structures",
      "数据结构",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "描述 AQS 的核心数据结构，以及它们在同步中的作用。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Data Structures",
      "数据结构",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 中的 Node 节点是如何组织的？它们的状态有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "解释 acquireShared 和 releaseShared 方法在共享模式下的工作原理。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 如何避免死锁？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Hard",
    "title": "如果自定义同步器，需要重写 AQS 的哪些方法？请给出具体例子。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 中的 tryAcquire 方法返回不同的值代表什么含义？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 如何处理中断信号？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Hard",
    "title": "AQS 的性能瓶颈可能出现在哪些地方？如何优化？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 在 CountDownLatch、CyclicBarrier 和 Semaphore 中的应用有什么不同？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "解释 AQS 的“模板方法模式”。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 中，如果等待队列过长，会产生什么问题？如何解决？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 的 doAcquireInterruptibly 方法和 acquireQueued 方法有什么区别？分别在什么情况下使用？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 如何保证在并发环境下，只有一个线程能够成功获取锁？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 中的 cancelAcquire 方法的作用是什么？什么情况下会调用它？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "如果一个线程在 AQS 的等待队列中，但是它不想继续等待了，应该如何操作？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 的状态 (state) 除了用于表示锁的持有状态，还可以用于其他用途吗？请举例说明。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "在自定义 AQS 同步器时，如何选择合适的同步模式（独占或共享）？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "AQS 的 hasQueuedPredecessors 方法的作用是什么？它在公平锁和非公平锁中的作用有什么不同？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Hard",
    "title": "如何使用 AQS 实现一个自定义的读写锁？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "AQS",
      "AQS"
    ],
    "difficulty": "Medium",
    "title": "谈谈你对 AQS 中 \"自旋\" 的理解，以及它对性能的影响。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 的特点是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 是如何实现可重入性的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 的 lock() 和 unlock() 方法应该如何使用？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 提供了哪些方法来尝试获取锁？它们有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 中的 Condition 是如何使用的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 的底层实现是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 的公平锁是如何保证公平性的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 的非公平锁有什么优势？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 中的 Condition 对象是如何与锁关联的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Hard",
    "title": "使用 ReentrantLock 实现一个简单的有界阻塞队列。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 的可重入性是如何影响性能的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "如何使用 ReentrantLock 来避免死锁？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 相比于 synchronized，在调试方面有什么优势？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "ReentrantLock 如何处理线程优先级反转问题？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Hard",
    "title": "分析 ReentrantLock 在高并发场景下的性能表现。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Hard",
    "title": "如何使用 ReentrantLock 实现一个线程安全的计数器？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Hard",
    "title": "在一个多线程环境中，如何使用 ReentrantLock 保护一个共享资源，避免数据竞争？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Hard",
    "title": "如何使用 ReentrantLock 和 Condition 实现生产者-消费者模式？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Hard",
    "title": "如何使用 ReentrantLock 实现一个可定时的任务调度器？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "在什么情况下，使用 ReentrantLock 的 tryLock 方法比 lock 方法更合适？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "如何通过监控 ReentrantLock 的状态，来诊断并发问题？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "如果在使用 ReentrantLock 时，忘记在 finally 块中释放锁，会发生什么问题？如何避免？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Hard",
    "title": "如何使用 ReentrantLock 实现一个简单的线程池？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Medium",
    "title": "在使用 ReentrantLock 时，如何选择合适的锁的公平性策略？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ReentrantLock",
      "ReentrantLock"
    ],
    "difficulty": "Hard",
    "title": "如何通过 ReentrantLock 实现一个简单的分布式锁？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Medium",
    "title": "Fork/Join主要用来解决什么样的问题？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Easy",
    "title": "Fork/Join框架是在哪个JDK版本中引入的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Medium",
    "title": "Fork/Join框架主要包含哪三个模块？模块之间的关系是怎么样的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Medium",
    "title": "ForkJoinPool类继承关系？ForkJoinTask抽象类继承关系？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Medium",
    "title": "在实际运用中，我们一般都会继承 RecursiveTask 、RecursiveAction 或 CountedCompleter 来实现我们的业务需求，而不会直接继承 ForkJoinTask 类。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Hard",
    "title": "整个Fork/Join 框架的执行流程/运行机制是怎么样的？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Hard",
    "title": "具体阐述Fork/Join的分治思想和work-stealing 实现方式？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Medium",
    "title": "有哪些JDK源码中使用了Fork/Join思想？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Medium",
    "title": "如何使用Executors工具类创建ForkJoinPool？"
  },
  {
    "type": "Coding",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "Algorithms",
      "算法",
      "ForkJoinPool"
    ],
    "difficulty": "Medium",
    "title": "写一个例子: 用ForkJoin方式实现1+2+3+...+100000？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java",
      "ForkJoinPool"
    ],
    "difficulty": "Medium",
    "title": "Fork/Join在使用时有哪些注意事项？结合JDK中的斐波那契数列实例具体说明。"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "进程间通信和线程间通信的几种方式和区别"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "为什么要有虚拟内存？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "malloc 是如何分配内存的？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "内存满了，会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "在 4GB 物理内存的机器上，申请 8G 内存会怎么样？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "如何避免预读失效和缓存污染的问题？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "什么是预读机制？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "预读失效会带来什么问题？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "如何避免预读失效造成的影响？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "什么是缓存污染？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "缓存污染会带来什么问题？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "怎么避免缓存污染造成的影响？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "深入理解 Linux 虚拟内存管理"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "深入理解 Linux 物理内存管理"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Medium",
    "title": "缓存写策略：写直达（Write Through）与写回（Write Back）的区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "什么是CPU缓存一致性问题？如何保证缓存一致性？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Hard",
    "title": "解释MESI协议及其四种状态（Modified, Exclusive, Shared, Invalidated）。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "Data Representation",
      "数据表示"
    ],
    "difficulty": "Easy",
    "title": "为什么计算机中使用补码来表示负数？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "Data Representation",
      "数据表示"
    ],
    "difficulty": "Easy",
    "title": "十进制小数如何转换为二进制表示？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "Data Representation",
      "数据表示"
    ],
    "difficulty": "Medium",
    "title": "计算机是如何存储浮点数的？请解释IEEE 754标准。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "Data Representation",
      "数据表示"
    ],
    "difficulty": "Medium",
    "title": "为什么在很多编程语言中，0.1 + 0.2 不等于 0.3？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Easy",
    "title": "为什么在CPU和主内存之间需要CPU Cache（高速缓存）？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Easy",
    "title": "什么是缓存行（Cache Line）？它的大小通常是多少？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "什么是CPU缓存伪共享（False Sharing）？如何避免伪共享问题？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "CPU Scheduling",
      "CPU调度"
    ],
    "difficulty": "Medium",
    "title": "Linux内核是如何调度普通任务的？解释一下CFS（完全公平调度器）和vruntime。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "CPU Scheduling",
      "CPU调度"
    ],
    "difficulty": "Easy",
    "title": "在Linux中，如何调整一个正在运行进程的优先级？（nice, renice）"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构"
    ],
    "difficulty": "Easy",
    "title": "请简述冯诺依曼体系结构的主要组成部分。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构"
    ],
    "difficulty": "Easy",
    "title": "32位CPU和64位CPU的主要区别是什么？64位一定比32位快很多吗？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机体系结构"
    ],
    "difficulty": "Medium",
    "title": "32位操作系统能否运行在64位CPU上？64位操作系统能否运行在32位CPU上？为什么？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构"
    ],
    "difficulty": "Medium",
    "title": "描述CPU执行一条指令的基本周期（取指、译码、执行、写回）。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "哪些因素会影响程序在CPU上的执行速度？（指令数、CPI、时钟频率）"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Easy",
    "title": "解释CPU缓存的不同级别（L1, L2, L3）及其特点。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如何编写代码以提高CPU数据缓存的命中率？（例如：数组遍历顺序）"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "CPU Cache",
      "CPU缓存",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如何编写代码以提高CPU指令缓存的命中率？（例如：利用分支预测）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机体系结构",
      "Concurrency",
      "并发",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "在多核CPU系统中，CPU亲和性（CPU Affinity）如何帮助提高程序性能？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Easy",
    "title": "什么是中断？它在操作系统中起什么作用？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Medium",
    "title": "硬中断和软中断（Softirq）的主要区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Medium",
    "title": "为什么Linux将中断处理分为上半部（Top Half）和下半部（Bottom Half）？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Interrupts",
      "中断",
      "Troubleshooting",
      "故障排查"
    ],
    "difficulty": "Easy",
    "title": "在Linux系统中，如何查看软中断（Softirq）的统计信息？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Interrupts",
      "中断",
      "Troubleshooting",
      "故障排查",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如果发现系统软中断CPU使用率过高，你会如何诊断和定位问题？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Easy",
    "title": "描述计算机的存储层次结构（寄存器、缓存、内存、硬盘）。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "比较SRAM和DRAM的特点、用途和成本。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机体系结构",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Easy",
    "title": "简述不同存储层级（缓存、内存、SSD、HDD）在访问速度和成本上的大致差异。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Easy",
    "title": "虚拟内存的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "Linux 进程的内存布局是怎样的？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "内存分段和内存分页的区别和优缺点是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理",
      "Computer Architecture",
      "计算机体系结构"
    ],
    "difficulty": "Medium",
    "title": "多级页表和 TLB 是如何工作的？它们解决了什么问题？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理",
      "C Programming",
      "C语言"
    ],
    "difficulty": "Medium",
    "title": "malloc 是如何分配内存的？(brk 和 mmap 的区别)"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理",
      "C Programming",
      "C语言"
    ],
    "difficulty": "Medium",
    "title": "free() 函数如何知道要释放多大的内存？free 后内存会立即归还给 OS 吗？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "在 4GB 物理内存的 64 位机器上申请 8G 内存会发生什么？需要考虑哪些因素？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "什么是 Swap 机制？它在什么情况下会被触发？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "系统内存不足时，Linux 会如何回收内存？(kswapd, 直接回收, OOM)"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "文件页和匿名页的回收方式有什么不同？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "什么是 OOM Killer？它是如何选择进程杀死的？如何调整？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Database",
      "数据库",
      "MySQL",
      "MySQL",
      "Cache",
      "缓存",
      "Algorithms",
      "算法",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Hard",
    "title": "解释 Linux/MySQL 中改进的 LRU 算法如何解决预读失效和缓存污染问题。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Linux",
      "Linux",
      "Performance Tuning",
      "性能调优",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Hard",
    "title": "swappiness, min_free_kbytes, zone_reclaim_mode 这些内核参数的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Thread",
      "线程",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "一个进程最多可以创建多少个线程？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Deadlock",
      "死锁",
      "Thread",
      "线程"
    ],
    "difficulty": "Medium",
    "title": "如何避免死锁？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Deadlock",
      "死锁"
    ],
    "difficulty": "Easy",
    "title": "死锁产生的四个必要条件是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Deadlock",
      "死锁",
      "Debugging",
      "调试"
    ],
    "difficulty": "Hard",
    "title": "如何使用 pstack/gdb 等工具排查死锁问题？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Synchronization",
      "同步",
      "Mutual Exclusion",
      "互斥",
      "Thread",
      "线程"
    ],
    "difficulty": "Medium",
    "title": "多线程冲突与同步互斥机制"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Race Condition",
      "竞争条件"
    ],
    "difficulty": "Easy",
    "title": "什么是竞争条件（Race Condition）？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Critical Section",
      "临界区"
    ],
    "difficulty": "Easy",
    "title": "什么是临界区（Critical Section）？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Synchronization",
      "同步",
      "Mutual Exclusion",
      "互斥"
    ],
    "difficulty": "Medium",
    "title": "同步（Synchronization）与互斥（Mutual Exclusion）的区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Locking",
      "锁",
      "Spinlock",
      "自旋锁"
    ],
    "difficulty": "Medium",
    "title": "锁的实现方式（忙等待锁与无忙等待锁）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Semaphore",
      "信号量",
      "Synchronization",
      "同步",
      "Mutual Exclusion",
      "互斥"
    ],
    "difficulty": "Medium",
    "title": "信号量（Semaphore）及其 P/V 操作如何实现互斥与同步？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Synchronization",
      "同步",
      "Producer-Consumer Problem",
      "生产者消费者问题",
      "Semaphore",
      "信号量"
    ],
    "difficulty": "Medium",
    "title": "生产者消费者问题及其信号量解决方案"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Synchronization",
      "同步",
      "Deadlock",
      "死锁",
      "Dining Philosophers Problem",
      "哲学家就餐问题",
      "Semaphore",
      "信号量"
    ],
    "difficulty": "Hard",
    "title": "哲学家就餐问题及其解决方案（避免死锁）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Synchronization",
      "同步",
      "Readers-Writers Problem",
      "读者写者问题",
      "Semaphore",
      "信号量"
    ],
    "difficulty": "Hard",
    "title": "读者写者问题及其解决方案（读者优先、写者优先、公平）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Locking",
      "锁",
      "Pessimistic Lock",
      "悲观锁",
      "Optimistic Lock",
      "乐观锁",
      "Database",
      "数据库"
    ],
    "difficulty": "Medium",
    "title": "什么是悲观锁和乐观锁？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Locking",
      "锁",
      "Mutex",
      "互斥锁",
      "Spinlock",
      "自旋锁"
    ],
    "difficulty": "Medium",
    "title": "互斥锁（Mutex）和自旋锁（Spinlock）的区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Locking",
      "锁",
      "Read-Write Lock",
      "读写锁"
    ],
    "difficulty": "Medium",
    "title": "什么是读写锁？读者优先、写者优先、公平读写锁的区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Atomic Operation",
      "原子操作",
      "CAS",
      "比较并交换"
    ],
    "difficulty": "Medium",
    "title": "CAS（Compare-And-Swap）原子操作的原理是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程"
    ],
    "difficulty": "Easy",
    "title": "什么是进程？进程和程序的区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发",
      "Parallelism",
      "并行"
    ],
    "difficulty": "Easy",
    "title": "并发（Concurrency）和并行（Parallelism）的区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Process State",
      "进程状态"
    ],
    "difficulty": "Easy",
    "title": "进程有哪些状态？（运行、就绪、阻塞等）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "PCB",
      "进程控制块"
    ],
    "difficulty": "Medium",
    "title": "什么是进程控制块（PCB）？它包含哪些信息？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "PCB",
      "进程控制块"
    ],
    "difficulty": "Medium",
    "title": "PCB 是如何组织的？（例如，状态队列链表）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Process Management",
      "进程管理"
    ],
    "difficulty": "Medium",
    "title": "描述进程的创建、终止、阻塞和唤醒过程"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Context Switching",
      "上下文切换"
    ],
    "difficulty": "Medium",
    "title": "什么是上下文切换？进程上下文切换会发生什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Thread",
      "线程",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Easy",
    "title": "为什么使用线程？线程的优缺点是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Thread",
      "线程",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Easy",
    "title": "进程和线程的主要区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Thread",
      "线程",
      "Context Switching",
      "上下文切换"
    ],
    "difficulty": "Medium",
    "title": "线程上下文切换会发生什么？与进程上下文切换有何不同？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Thread",
      "线程",
      "User Thread",
      "用户线程",
      "Kernel Thread",
      "内核线程",
      "LWP",
      "轻量级进程"
    ],
    "difficulty": "Hard",
    "title": "描述不同的线程实现模型（用户线程、内核线程、轻量级进程 LWP）及其优缺点"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Scheduling",
      "调度",
      "Process",
      "进程",
      "Thread",
      "线程"
    ],
    "difficulty": "Medium",
    "title": "什么是进程/线程调度？调度发生在哪些时机？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Scheduling",
      "调度",
      "Scheduling Algorithm",
      "调度算法"
    ],
    "difficulty": "Medium",
    "title": "调度算法的设计原则有哪些？（CPU利用率、吞吐量、周转时间、等待时间、响应时间）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Scheduling",
      "调度",
      "Scheduling Algorithm",
      "调度算法"
    ],
    "difficulty": "Medium",
    "title": "描述常见的调度算法（FCFS, SJF, HRRN, RR, HPF, MFQ）及其特点"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Inter-Process Communication",
      "进程间通信",
      "IPC"
    ],
    "difficulty": "Medium",
    "title": "进程间有哪些通信方式？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Inter-Process Communication",
      "进程间通信",
      "IPC",
      "Pipe",
      "管道"
    ],
    "difficulty": "Medium",
    "title": "解释管道（匿名管道与命名管道/FIFO）通信机制"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Inter-Process Communication",
      "进程间通信",
      "IPC",
      "Message Queue",
      "消息队列"
    ],
    "difficulty": "Medium",
    "title": "解释消息队列（Message Queue）通信机制"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Inter-Process Communication",
      "进程间通信",
      "IPC",
      "Shared Memory",
      "共享内存"
    ],
    "difficulty": "Medium",
    "title": "解释共享内存（Shared Memory）通信机制"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Inter-Process Communication",
      "进程间通信",
      "IPC",
      "Semaphore",
      "信号量",
      "Synchronization",
      "同步",
      "Mutual Exclusion",
      "互斥"
    ],
    "difficulty": "Medium",
    "title": "解释信号量（Semaphore）在进程间通信中的作用（互斥与同步）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Inter-Process Communication",
      "进程间通信",
      "IPC",
      "Signal",
      "信号"
    ],
    "difficulty": "Medium",
    "title": "解释信号（Signal）作为异步通信机制"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Inter-Process Communication",
      "进程间通信",
      "IPC",
      "Networking",
      "网络",
      "Socket",
      "套接字"
    ],
    "difficulty": "Medium",
    "title": "解释套接字（Socket）通信（包括跨网络和本地）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Thread",
      "线程",
      "Error Handling",
      "错误处理",
      "JVM",
      "Java虚拟机"
    ],
    "difficulty": "Medium",
    "title": "线程崩溃了，进程也会崩溃吗？（区分 C/C++ 与 Java）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Thread",
      "线程",
      "Memory Management",
      "内存管理",
      "C++",
      "C++"
    ],
    "difficulty": "Medium",
    "title": "为什么在 C/C++ 中线程崩溃（如非法内存访问）通常会导致进程崩溃？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Signal",
      "信号"
    ],
    "difficulty": "Medium",
    "title": "信号（Signal）机制在进程终止中是如何工作的？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process",
      "进程",
      "Thread",
      "线程",
      "JVM",
      "Java虚拟机",
      "Error Handling",
      "错误处理",
      "Signal",
      "信号"
    ],
    "difficulty": "Hard",
    "title": "为什么在 Java 中线程崩溃（如 StackOverflowError 或 NPE）不会导致 JVM 进程崩溃？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process Scheduling",
      "进程调度"
    ],
    "difficulty": "Medium",
    "title": "比较不同的进程调度算法（如 FCFS, SJF, RR, 优先级, MLFQ）的优缺点。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Process Scheduling",
      "进程调度"
    ],
    "difficulty": "Easy",
    "title": "什么是抢占式调度和非抢占式调度？它们有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "比较不同的页面置换算法（如 OPT, FIFO, LRU, Clock, LFU）的原理和优缺点。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "解释缺页中断（Page Fault）的处理过程。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Medium",
    "title": "比较不同的磁盘调度算法（如 FCFS, SSTF, SCAN, C-SCAN, LOOK, C-LOOK）的目标和特性。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "File System",
      "文件系统"
    ],
    "difficulty": "Medium",
    "title": "解释文件系统的基本组成：索引节点（inode）和目录项（dentry）的作用和关系。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "File System",
      "文件系统"
    ],
    "difficulty": "Easy",
    "title": "什么是虚拟文件系统（VFS）？它的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "File System",
      "文件系统"
    ],
    "difficulty": "Medium",
    "title": "比较文件的不同存储方式（连续、链表、索引）的优缺点。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "File System",
      "文件系统"
    ],
    "difficulty": "Easy",
    "title": "硬链接（Hard Link）和软链接（Symbolic Link）有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Medium",
    "title": "解释缓冲 I/O 与非缓冲 I/O，直接 I/O 与非直接 I/O 的区别。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Medium",
    "title": "解释阻塞 I/O、非阻塞 I/O、同步 I/O、异步 I/O 的区别和联系。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "什么是 Linux 的 Page Cache？它的作用和优缺点是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Easy",
    "title": "Page Cache 和 Buffer Cache 有什么区别和联系？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "Page Cache 如何保证数据一致性？（Write Through vs Write Back）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Medium",
    "title": "解释 DMA（直接内存访问）的工作原理及其解决了什么问题。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Easy",
    "title": "设备驱动程序的作用是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Medium",
    "title": "键盘敲入一个字母时，操作系统内部发生了什么？（中断处理过程）"
  },
  {
    "type": "Question",
    "category": [
      "System Design",
      "系统设计",
      "Algorithms",
      "算法",
      "Hash Table",
      "哈希表"
    ],
    "difficulty": "Medium",
    "title": "什么是一致性哈希？它解决了什么问题？"
  },
  {
    "type": "Question",
    "category": [
      "System Design",
      "系统设计",
      "Algorithms",
      "算法",
      "Hash Table",
      "哈希表"
    ],
    "difficulty": "Medium",
    "title": "一致性哈希中的虚拟节点是如何解决数据倾斜问题的？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Hard",
    "title": "解释 Reactor 模式及其不同的实现方式（单 Reactor 单线程/多线程，多 Reactor 多线程）。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Hard",
    "title": "Reactor 模式和 Proactor 模式有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "什么是 I/O 多路复用？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Hard",
    "title": "比较 select、poll、epoll 的实现原理和优缺点。"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "epoll 的水平触发（LT）和边缘触发（ET）有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Medium",
    "title": "什么是零拷贝（Zero-copy）？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Hard",
    "title": "解释实现零拷贝的几种方式（mmap+write, sendfile）及其原理。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络",
      "I/O Management",
      "I/O管理"
    ],
    "difficulty": "Medium",
    "title": "零拷贝和 PageCache 的关系是什么？传输大文件时为什么不建议用零拷贝？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络"
    ],
    "difficulty": "Easy",
    "title": "衡量网络性能的主要指标有哪些？（带宽、延时、吞吐率、PPS）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络",
      "Linux"
    ],
    "difficulty": "Easy",
    "title": "如何使用 Linux 命令（如 ifconfig/ip, netstat/ss, sar, ping, ethtool）查看网络配置和性能指标？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络",
      "Linux"
    ],
    "difficulty": "Medium",
    "title": "netstat/ss 命令输出中 Recv-Q 和 Send-Q 在不同 socket 状态下分别代表什么？"
  },
  {
    "type": "Question",
    "category": [
      "Linux",
      "Linux",
      "Data Analysis",
      "数据分析"
    ],
    "difficulty": "Medium",
    "title": "如何使用 Linux Shell 命令（awk, sort, uniq, wc）从 Nginx 日志中分析 PV 和 UV？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Medium",
    "title": "CPU Cache 的数据写入方式有哪些？（写直达 vs 写回）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "什么是缓存一致性问题？如何解决？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Hard",
    "title": "解释 MESI 协议。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Hard",
    "title": "MESI 协议的四种状态是什么？它们之间如何转换？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "什么是总线嗅探？它在缓存一致性中扮演什么角色？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理",
      "Data Representation",
      "数据表示"
    ],
    "difficulty": "Easy",
    "title": "为什么负数要用补码表示？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理",
      "Data Representation",
      "数据表示"
    ],
    "difficulty": "Easy",
    "title": "十进制小数如何转换为二进制？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理",
      "Data Representation",
      "数据表示",
      "Floating Point",
      "浮点数"
    ],
    "difficulty": "Medium",
    "title": "计算机是如何存储小数的？（IEEE 754 浮点数标准）"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理",
      "Data Representation",
      "数据表示",
      "Floating Point",
      "浮点数"
    ],
    "difficulty": "Medium",
    "title": "为什么 0.1 + 0.2 不等于 0.3？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理",
      "Data Representation",
      "数据表示",
      "Floating Point",
      "浮点数"
    ],
    "difficulty": "Medium",
    "title": "单精度和双精度浮点数有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Easy",
    "title": "CPU 缓存的层次结构是怎样的？为什么需要多级缓存？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Easy",
    "title": "什么是 CPU Cache Line？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Hard",
    "title": "什么是伪共享（False Sharing）？如何避免？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "CPU Scheduling",
      "CPU调度"
    ],
    "difficulty": "Medium",
    "title": "Linux 中的任务调度策略有哪些？（实时任务 vs 普通任务）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "CPU Scheduling",
      "CPU调度"
    ],
    "difficulty": "Medium",
    "title": "解释 CFS（完全公平调度）算法。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "CPU Scheduling",
      "CPU调度"
    ],
    "difficulty": "Medium",
    "title": "什么是 vruntime？它在 CFS 中如何工作？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "CPU Scheduling",
      "CPU调度"
    ],
    "difficulty": "Easy",
    "title": "如何调整 Linux 任务的优先级？（nice 值）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理"
    ],
    "difficulty": "Medium",
    "title": "CPU 是如何执行程序的？（指令周期）"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理"
    ],
    "difficulty": "Easy",
    "title": "解释冯诺依曼模型的基本组成部分。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理"
    ],
    "difficulty": "Medium",
    "title": "CPU 中的寄存器有哪些主要类型及其作用？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理"
    ],
    "difficulty": "Easy",
    "title": "32 位和 64 位 CPU 的主要区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理"
    ],
    "difficulty": "Easy",
    "title": "64 位 CPU 的计算性能一定比 32 位 CPU 高很多吗？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理"
    ],
    "difficulty": "Medium",
    "title": "解释指令流水线的基本阶段。"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如何衡量和提高程序的 CPU 执行速度？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Easy",
    "title": "为什么需要 CPU Cache？它比内存快多少？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Medium",
    "title": "CPU Cache 的数据结构是怎样的？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Medium",
    "title": "解释直接映射缓存（Direct Mapped Cache）的工作原理。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如何编写能提高 CPU 数据缓存命中率的代码？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "如何编写能提高 CPU 指令缓存命中率的代码？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "什么是分支预测？它如何影响性能？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存",
      "Concurrency",
      "并发",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Medium",
    "title": "在多核 CPU 上，如何提高缓存命中率？（线程绑定）"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Easy",
    "title": "什么是中断？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Easy",
    "title": "为什么中断处理程序需要短而快？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Medium",
    "title": "什么是软中断？它与硬中断有何区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Medium",
    "title": "Linux 为什么要将中断处理分为上半部和下半部？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Medium",
    "title": "Linux 中常见的软中断类型有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Linux",
      "Linux",
      "Troubleshooting",
      "故障排查",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Medium",
    "title": "如何查看和分析 Linux 系统中的软中断情况？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Linux",
      "Linux",
      "Troubleshooting",
      "故障排查",
      "Performance Optimization",
      "性能优化",
      "Interrupts",
      "中断"
    ],
    "difficulty": "Hard",
    "title": "如何定位软中断 CPU 使用率过高的问题？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Easy",
    "title": "描述计算机的存储器层次结构。"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Easy",
    "title": "不同层级的存储器在速度、容量、成本上有何差异？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理",
      "Memory Management",
      "内存管理"
    ],
    "difficulty": "Medium",
    "title": "SRAM 和 DRAM 有什么区别？它们分别用于什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Computer Architecture",
      "计算机组成原理",
      "CPU Cache",
      "CPU缓存"
    ],
    "difficulty": "Medium",
    "title": "CPU 访问数据的流程是怎样的（考虑缓存）？"
  },
  {
    "type": "Question",
    "category": [
      "Computer Architecture",
      "计算机组成原理",
      "Storage",
      "存储"
    ],
    "difficulty": "Easy",
    "title": "机械硬盘、固态硬盘、内存的速度大约相差多少倍？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Kernel",
      "内核"
    ],
    "difficulty": "Easy",
    "title": "内核在操作系统中扮演什么角色？提供哪些基本能力？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Kernel",
      "内核"
    ],
    "difficulty": "Easy",
    "title": "什么是用户态和内核态？为什么需要区分？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Kernel",
      "内核",
      "System Call",
      "系统调用"
    ],
    "difficulty": "Easy",
    "title": "应用程序如何从用户态切换到内核态？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Linux",
      "Linux",
      "Kernel",
      "内核"
    ],
    "difficulty": "Medium",
    "title": "Linux 内核的设计理念有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Kernel",
      "内核"
    ],
    "difficulty": "Medium",
    "title": "宏内核、微内核、混合内核各有什么特点和优缺点？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Linux",
      "Linux",
      "Windows",
      "Windows",
      "Kernel",
      "内核"
    ],
    "difficulty": "Medium",
    "title": "Linux 和 Windows 内核的主要区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Linux",
      "Linux",
      "Windows",
      "Windows",
      "File Format",
      "文件格式"
    ],
    "difficulty": "Medium",
    "title": "Linux 和 Windows 的可执行文件格式分别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库"
    ],
    "difficulty": "Medium",
    "title": "分库分表怎么分"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库"
    ],
    "difficulty": "Medium",
    "title": "SharingSphere怎么查数据的总量"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread",
      "线程"
    ],
    "difficulty": "Medium",
    "title": "为什么要用ThreadLocal，ThreadLocal的原理"
  },
  {
    "type": "Question",
    "category": [
      "Algorithms",
      "算法"
    ],
    "difficulty": "Medium",
    "title": "布隆过滤器原理和特点"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池处理任务的流程"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "面对一个有很多任务的场景，依据什么原则去设计线程池的线程数"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库"
    ],
    "difficulty": "Medium",
    "title": "ACID特性分别怎么实现"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "Tree",
      "树"
    ],
    "difficulty": "Medium",
    "title": "为什么要用B+树"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库"
    ],
    "difficulty": "Medium",
    "title": "LIMIT分页查询为什么后面页面的查询会很慢"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库"
    ],
    "difficulty": "Medium",
    "title": "索引失效有哪些场景"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "两个new Integer（100）是否=="
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Spring",
      "Spring"
    ],
    "difficulty": "Medium",
    "title": "用Spring的时候怎么避免循环依赖"
  },
  {
    "type": "Question",
    "category": [
      "Java"
    ],
    "difficulty": "Medium",
    "title": "类型擦除问题，ArrayList<Int>可以存入一个String吗？"
  },
  {
    "type": "Question",
    "category": [
      "Java"
    ],
    "difficulty": "Medium",
    "title": "java序列化生成的uuid有什么用？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "java有哪些锁？讲讲AQS"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "synchronizied锁的原理"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Hard",
    "title": "CAS操作怎么避免ABA问题"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "volatile关键字有什么用？"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "String",
      "字符串"
    ],
    "difficulty": "Medium",
    "title": "redis的String结构和java的String有什么不同"
  },
  {
    "type": "Question",
    "category": [
      "Redis",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Medium",
    "title": "redis的ZSET了解吗？底层是什么结构"
  },
  {
    "type": "Question",
    "category": [
      "Redis"
    ],
    "difficulty": "Medium",
    "title": "redis为什么这么快，为什么不使用多线程？"
  },
  {
    "type": "Question",
    "category": [
      "Redis"
    ],
    "difficulty": "Medium",
    "title": "了解Redis Cluster吗？多加几个实例数据要怎么迁移?"
  },
  {
    "type": "Question",
    "category": [
      "Redis"
    ],
    "difficulty": "Medium",
    "title": "redis某个key过期了，删除策略有哪些？"
  }
]