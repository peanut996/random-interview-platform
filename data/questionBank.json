[
  {
    "type": "Coding",
    "title": "接雨水",
    "category": [
      "LeetCode",
      "Array",
      "Dynamic Programming",
      "Stack",
      "Two Pointers"
    ],
    "difficulty": "Hard"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "Data Structures",
      "数据结构",
      "Redis"
    ],
    "difficulty": "Medium",
    "title": "ZSET表的原理，怎么实现的用户登录限流，表占用过大时是手动还是自动删除数据，占用上限是如何设置的"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络"
    ],
    "difficulty": "Hard",
    "title": "Epoll的原理"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Tree",
      "树"
    ],
    "difficulty": "Hard",
    "title": "红黑树的原理，在Epoll中红黑树的键值分别是什么"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Networking",
      "网络"
    ],
    "difficulty": "Hard",
    "title": "epoll_wait返回的队列是由谁将事件加入队列的"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池有几个分别是什么作用"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "Linux中的硬连接和软连接，硬连接软连接可以比作哪些智能指针"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "虚拟内存，不同操作系统下页表是几级"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "中断机制是怎么处理的"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "Dynamic Programming",
      "动态规划",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "最长公共子序列"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "String",
      "字符串",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "无重复最长子串"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "UDP"
    ],
    "difficulty": "Medium",
    "title": "TCP和UDP的区别"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "Array",
      "数组",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "区间合并"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Golang",
      "Go"
    ],
    "difficulty": "Medium",
    "title": "进程线程协程，gmp调度？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "乐观锁和悲观锁？讲讲怎么实现？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "死锁的条件？解决办法？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "MySQL事务特性以及实现"
  },
  {
    "type": "Question",
    "category": [
      "System Design",
      "系统设计"
    ],
    "difficulty": "Hard",
    "title": "如果你的项目有千万级的用户量，你怎么优化"
  },
  {
    "type": "Question",
    "category": [
      "Design Patterns",
      "设计模式"
    ],
    "difficulty": "Easy",
    "title": "设计模式了解过哪些"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "Graph",
      "图",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "岛屿数量"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "TCP",
      "UDP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "TCP和UDP区别，HTTP用的谁，为什么？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "HTTP状态码"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "TCP",
      "UDP"
    ],
    "difficulty": "Medium",
    "title": "HTTP是长连接还是短连接，如何用UDP实现"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "MySQL索引如何实现的。"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "MySQL索引为什么用B+不用B树？如果把内容存在内存上，用B树会不会快一点。"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表",
      "MySQL"
    ],
    "difficulty": "Medium",
    "title": "分库分表的常用中间件有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Hard",
    "title": "有哪些问题中间件无法提供帮助、只能改写业务代码的场景？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "MySQL",
      "分库分表"
    ],
    "difficulty": "Easy",
    "title": "分库分表使用了什么中间件？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Medium",
    "title": "分库分表的实现场景和方式有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Medium",
    "title": "分表之后，要查询两个表的数据要怎么查？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Medium",
    "title": "分库分表的优缺点是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Hard",
    "title": "分库分表业界有哪些替代方案？（提示：分布式文件系统，因为分库分表会出现降低QPS，比如range查询失效）"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Hard",
    "title": "为什么做了分库分表后分页比较困难了？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Hard",
    "title": "如果10亿数据要分表，要怎么分？业务怎么切？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "Concurrency",
      "并发",
      "分库分表"
    ],
    "difficulty": "Hard",
    "title": "分库分表怎么保证数据一致性？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Medium",
    "title": "分库分表选的什么分片键？什么分片算法？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "分库分表"
    ],
    "difficulty": "Medium",
    "title": "分库分表后的分布式ID怎么做？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Concurrency",
      "并发",
      "动态代理"
    ],
    "difficulty": "Medium",
    "title": "JDK和Cglib动态代理有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Array",
      "数组",
      "Linked List",
      "链表",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "ArrayList和LinkedList的区别？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Hash Table",
      "哈希表",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "HashMap原理?"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Tree",
      "树",
      "Binary Search Tree",
      "二叉搜索树",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "红黑树红和黑代表什么?"
  },
  {
    "type": "Coding",
    "category": [
      "Data Structures",
      "数据结构",
      "Hash Table",
      "哈希表",
      "Array",
      "数组",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "HashMap数组索引怎么确认？"
  },
  {
    "type": "Question",
    "category": [
      "Algorithms",
      "算法",
      "Hash Table",
      "哈希表",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "常见的哈希算法了解哪些？解决哈希冲突的方法?"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "Java有什么集合容器？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Tree",
      "树",
      "Sorting",
      "排序",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "Treemap怎么排序，有什么注意事项，可不可以自定义排序，排序的数据结构是什么"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Concurrency",
      "并发",
      "Array",
      "数组",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "CopyOnWriteArrayList怎么保证线程安全，优点是这个，那缺点呢？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Concurrency",
      "并发",
      "Array",
      "数组",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "ArrayList线程安全吗，想要使用线程安全的ArrayList怎么办？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Hash Table",
      "哈希表",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "假设你要遍历一个 HashMap，同时删除一些 key，应该怎么编写代码？"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Concurrency",
      "并发",
      "Hash Table",
      "哈希表",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "HashTable怎么保证线程安全的，ConcurrentHashMap呢，怎么去选择呢"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Hash Table",
      "哈希表",
      "Tree",
      "树",
      "Binary Search Tree",
      "二叉搜索树",
      "Java"
    ],
    "difficulty": "Hard",
    "title": "Hashmap 为什么选择红黑树而不是AVL"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Reflection",
      "反射"
    ],
    "difficulty": "Medium",
    "title": "你对Java的反射如何理解的，原理是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Reflection",
      "反射"
    ],
    "difficulty": "Medium",
    "title": "反射机制对于其他没有反射的语言有什么好处？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Reflection",
      "反射"
    ],
    "difficulty": "Medium",
    "title": "Java中哪些效率高的功能是基于反射做的呢？"
  },
  {
    "type": "Question",
    "category": [
      "String",
      "字符串",
      "Java",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "byte怎么转字符串？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Reflection",
      "反射"
    ],
    "difficulty": "Medium",
    "title": "反射的应用场景"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Reflection",
      "反射"
    ],
    "difficulty": "Medium",
    "title": "反射为什么性能开销高"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "volatile 关键字的作用是什么？不加这个关键字对变量修改就不会加到主存吗？加了这个关键字还需要加锁吗？这个关键字的一些应用场景都有哪些呢？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池",
      "Java"
    ],
    "difficulty": "Hard",
    "title": "假设让你写一个线程池工具，你觉得应该怎么去设计呢？应该有什么变量？有什么接口？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "比如核心线程数量是5，最大线程是10，现在来了11个任务，怎么调度？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "线程池的执行流程?"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "线程池是否会出现并发安全问题?"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "动态线程池是怎么实现的？动态调整机制是什么？我们应该设置多少核心线程数和最大线程数，以及通过哪里去设置？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "动态线程池的“动态”体现在什么地方？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Medium",
    "title": "线程池过程和原理"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Thread Pool",
      "线程池"
    ],
    "difficulty": "Hard",
    "title": "你怎么实际计算需要的核心线程数目和阻塞队列大小?你怎么设定拒绝策略?高请求下有的用户的请求被拒绝了，你会怎么处理反映给用户?"
  },
  {
    "type": "Question",
    "category": [
      "String",
      "字符串",
      "Java",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "String，StringBuilder，StringBuffer的区别?"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "synchronized和reentrantlock的区别？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "java乐观锁和悲观锁？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "Java 有哪些重要的锁？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Hard",
    "title": "AQS实现"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "有了synchornized为什么还会出现lock"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Operating System",
      "操作系统",
      "多线程",
      "Multi Threading"
    ],
    "difficulty": "Medium",
    "title": "多进程、多线程、多协程各自的优势和劣势？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "多线程",
      "Multi Threading"
    ],
    "difficulty": "Easy",
    "title": "Java有哪些线程状态？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Operating System",
      "操作系统",
      "Java",
      "Multi Threading"
    ],
    "difficulty": "Medium",
    "title": "如果一个进程创建了几万个线程会出现什么问题？"
  },
  {
    "type": "Coding",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Multi Threading",
      "多线程"
    ],
    "difficulty": "Medium",
    "title": "怎么让两个线程有序执行？"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "多线程如何做同步"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "线程的上下文切换需要切换什么东西"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "completablefuture 和 futuretask"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "Java线程怎么进入阻塞状态"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Java"
    ],
    "difficulty": "Easy",
    "title": "Java线程怎么进入Runnable状态"
  },
  {
    "type": "Question",
    "category": [
      "Concurrency",
      "并发",
      "Operating System",
      "操作系统",
      "Java"
    ],
    "difficulty": "Hard",
    "title": "Java线程上下文切换具体过程"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Medium",
    "title": "如果让你调研是否要从Java 8升级到更新的版本（如11或17），你会如何评估其必要性？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Medium",
    "title": "BigDecimal怎么存储，怎么计算，有什么注意事项，为什么他能保证不丢失"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Design Patterns",
      "设计模式"
    ],
    "difficulty": "Medium",
    "title": "JDK Proxy 和 CGLib Proxy 的区别"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Exception Handling",
      "异常处理"
    ],
    "difficulty": "Easy",
    "title": "Java中你遇到过哪些异常？你分别怎么处理？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Medium",
    "title": "团队升级JDK版本的话你怎么调研？"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Performance Optimization",
      "性能优化"
    ],
    "difficulty": "Hard",
    "title": "Java分配大对象怎么进行性能优化"
  },
  {
    "type": "Question",
    "category": [
      "Java",
      "Java",
      "Generics",
      "泛型"
    ],
    "difficulty": "Medium",
    "title": "泛型、反射和类型推断的关系"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Algorithms",
      "算法",
      "前端",
      "Front End"
    ],
    "difficulty": "Easy",
    "title": "前端常见的数据结构有哪些？有什么基础算法？有什么应用场景？"
  },
  {
    "type": "Question",
    "category": [
      "Algorithms",
      "算法"
    ],
    "difficulty": "Easy",
    "title": "什么是时间复杂度？"
  },
  {
    "type": "Question",
    "category": [
      "Algorithms",
      "算法"
    ],
    "difficulty": "Easy",
    "title": "什么是空间复杂度？"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "两数之和"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "买卖股票的最佳时机"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "盛水最多的容器"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "除自身以外数组的乘积"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "无重复字符的最长子串"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Easy",
    "title": "验证回文串"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "反转字符串中的单词"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "手写深拷贝"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Easy",
    "title": "手写 getType 函数"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 class 继承"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "使用 ES6 语法写出三种菜单的 class"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写防抖 Debounce"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写截流 Throttle"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 bind"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 call 和 apply"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 EventBus 自定义事件"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写数组拍平 Array Flatten"
  },
  {
    "type": "Coding",
    "category": [
      "String",
      "字符串",
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写解析 URL 参数为 JS 对象"
  },
  {
    "type": "Coding",
    "category": [
      "Array",
      "数组",
      "Algorithms",
      "算法"
    ],
    "difficulty": "Easy",
    "title": "手写数组去重"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法"
    ],
    "difficulty": "Medium",
    "title": "手写红绿灯"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Hard",
    "title": "手写 Promise"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Hard",
    "title": "手写 Promise.all"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Hard",
    "title": "手写 Promise.race"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Hard",
    "title": "手写 Promise.allSettled"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Hard",
    "title": "手写一个 LazyMan 实现 sleep 机制"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 curry 函数，实现函数柯里化"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "手写 compose 函数"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "Data Structures",
      "数据结构",
      "LeetCode"
    ],
    "difficulty": "Medium",
    "title": "手写一个 LRU 缓存"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End",
      "Vue"
    ],
    "difficulty": "Medium",
    "title": "使用 Vue3 Composable 组合式函数，实现 useCount"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End",
      "Vue"
    ],
    "difficulty": "Medium",
    "title": "使用 Vue3 Composable 组合式函数，实现 useRequest"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End",
      "React"
    ],
    "difficulty": "Medium",
    "title": "使用 React Hook 实现 useCount"
  },
  {
    "type": "Coding",
    "category": [
      "Algorithms",
      "算法",
      "JavaScript",
      "前端",
      "Front End",
      "React"
    ],
    "difficulty": "Medium",
    "title": "使用 React Hook 实现 useRequest"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "进程和线程的区别"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "进程间的通信"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "单核 CPU 如何实现并发"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "CPU 调度算法有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Linux"
    ],
    "difficulty": "Medium",
    "title": "linux 如何查找你的进程占用的那个端口"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "单核服务器连接数超载了怎么办"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题",
      "Operating System",
      "操作系统",
      "JavaScript",
      "前端",
      "Front End"
    ],
    "difficulty": "Medium",
    "title": "请简述一个编译器的执行过程。前端有哪些常见的编译工具？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题"
    ],
    "difficulty": "Medium",
    "title": "什么是编译型语言和解释型语言，他们有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "String",
      "字符串",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "简述 JS 垃圾回收的过程。用什么算法？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "什么是内存泄漏？如何排查？JS 内存泄漏的常见原因？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "简述 JS 运行时的堆栈内存模型？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题"
    ],
    "difficulty": "Medium",
    "title": "冯·诺依曼架构是什么？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题"
    ],
    "difficulty": "Medium",
    "title": "计算机内部为何使用二进制？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题"
    ],
    "difficulty": "Medium",
    "title": "二进制如何表示负数和小数？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "什么是虚拟内存，为何要使用虚拟内存？"
  },
  {
    "type": "Question",
    "category": [
      "Question",
      "问题"
    ],
    "difficulty": "Medium",
    "title": "什么是 Unicode 编码？它和常见的 UTF-8 有什么关系？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络"
    ],
    "difficulty": "Medium",
    "title": "简述计算机网络的 OSI 模型"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络"
    ],
    "difficulty": "Easy",
    "title": "一个域名对应一个 ip 吗"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络"
    ],
    "difficulty": "Medium",
    "title": "UDP 和 TCP 协议的区别？有什么应用场景"
  },
  {
    "type": "Question",
    "category": [
      "Data Structures",
      "数据结构",
      "Array",
      "数组",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "数组和链表有什么区别？从内存结构上来说"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "进程和线程的区别"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "进程间的通信"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "Concurrency",
      "并发"
    ],
    "difficulty": "Medium",
    "title": "单核 CPU 如何实现并发"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "CPU 调度算法有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "linux 如何查找你的进程占用的那个端口"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "单核服务器连接数超载了怎么办"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "请简述一个编译器的执行过程。前端有哪些常见的编译工具？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统"
    ],
    "difficulty": "Medium",
    "title": "什么是编译型语言和解释型语言，他们有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "简述 JS 垃圾回收的过程。用什么算法？"
  },
  {
    "type": "Question",
    "category": [
      "Operating System",
      "操作系统",
      "JavaScript"
    ],
    "difficulty": "Medium",
    "title": "什么是内存泄漏？如何排查？JS 内存泄漏的常见原因？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Basic Concepts",
      "基本概念"
    ],
    "difficulty": "Easy",
    "title": "DOCTYPE 是什么，都有哪些属性？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Meta",
      "元数据"
    ],
    "difficulty": "Easy",
    "title": "meta 标签是干什么的，都有什么属性和作用"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "DOM",
      "文档对象模型"
    ],
    "difficulty": "Easy",
    "title": "什么是 DOM ，它和 HTML 有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Semantic HTML",
      "语义化HTML"
    ],
    "difficulty": "Medium",
    "title": "如何理解 HTML5 语义化 ？有哪些常见的语义化标签？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "DOM",
      "文档对象模型",
      "Attributes vs Properties"
    ],
    "difficulty": "Medium",
    "title": "DOM 节点的 attr 和 property 有何区别"
  },
  {
    "type": "Coding",
    "category": [
      "HTML",
      "HTML",
      "DOM Manipulation",
      "DOM操作"
    ],
    "difficulty": "Medium",
    "title": "如何一次性插入多个 DOM 节点？考虑性能"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "DOM",
      "文档对象模型",
      "Dimensions"
    ],
    "difficulty": "Easy",
    "title": "offsetHeight scrollHeight clientHeight 有什么区别"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "DOM",
      "文档对象模型",
      "Collections"
    ],
    "difficulty": "Medium",
    "title": "HTMLCollection 和 NodeList 的区别"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "DOM",
      "文档对象模型",
      "Nodes"
    ],
    "difficulty": "Easy",
    "title": "Node 和 Element 有什么区别？"
  },
  {
    "type": "Coding",
    "category": [
      "HTML",
      "HTML",
      "Event Handling",
      "事件处理"
    ],
    "difficulty": "Medium",
    "title": "开发一个无限下拉加载图片的页面，如何给每个图片绑定 click 事件？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Event Handling",
      "事件处理",
      "Loading"
    ],
    "difficulty": "Easy",
    "title": "window.onload 和 DOMContentLoaded 的区别是什么？"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Performance",
      "性能",
      "Script Loading"
    ],
    "difficulty": "Medium",
    "title": "script 标签放在 head 里，怎么解决加载阻塞的问题"
  },
  {
    "type": "Question",
    "category": [
      "HTML",
      "HTML",
      "Basic Concepts",
      "基本概念",
      "Inline vs Block"
    ],
    "difficulty": "Easy",
    "title": "常见的 HTML 标签哪些是 inline 元素，哪些是 block 元素，哪些是 inline-block 元素"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Selectors",
      "选择器"
    ],
    "difficulty": "Easy",
    "title": "常见的 CSS 选择器有哪些？"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Box Model",
      "盒子模型"
    ],
    "difficulty": "Medium",
    "title": "CSS 盒子模型，尺寸计算"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "Margin Collapse"
    ],
    "difficulty": "Medium",
    "title": "margin 纵向重叠"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Text Styling",
      "文本样式",
      "Inheritance"
    ],
    "difficulty": "Easy",
    "title": "lineHeight 如何继承？"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "Negative Margin"
    ],
    "difficulty": "Medium",
    "title": "margin 负值问题"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "BFC"
    ],
    "difficulty": "Medium",
    "title": "什么是 BFC 如何触发 BFC？"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "Centering"
    ],
    "difficulty": "Medium",
    "title": "使用 CSS 实现居中对齐，有哪几种方式？"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Positioning",
      "定位",
      "Positioning Context"
    ],
    "difficulty": "Medium",
    "title": "什么是 CSS 定位上下文？absolute 和 relative 分别依据谁来定位？"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Visibility",
      "可见性"
    ],
    "difficulty": "Easy",
    "title": "CSS overflow: hidden display：none 和 visibility: hidden 有什么区别"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Units",
      "单位"
    ],
    "difficulty": "Easy",
    "title": "CSS px % em rem vw/vh 的区别"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "UI",
      "Retina"
    ],
    "difficulty": "Medium",
    "title": "如何实现 Retina 屏 1px 像素边框"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "UI",
      "Triangle"
    ],
    "difficulty": "Easy",
    "title": "使用 CSS 画一个三角形"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "UI",
      "Theme"
    ],
    "difficulty": "Medium",
    "title": "如何实现黑白主题变化？"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "Responsive Design"
    ],
    "difficulty": "Medium",
    "title": "如何实现响应式布局？"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Z-index"
    ],
    "difficulty": "Easy",
    "title": "如何理解 z-index ？"
  },
  {
    "type": "Coding",
    "category": [
      "CSS",
      "CSS",
      "Layout",
      "布局",
      "Flexbox"
    ],
    "difficulty": "Hard",
    "title": "使用 flex 设计一个“四合院”布局"
  },
  {
    "type": "Question",
    "category": [
      "CSS",
      "CSS",
      "Tools",
      "工具",
      "Frameworks",
      "预处理器"
    ],
    "difficulty": "Medium",
    "title": "你用过哪些 CSS 相关的技术，如库、框架、预处理语言、后处理语言等"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Easy",
    "title": "TS 优缺点，使用场景"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Easy",
    "title": "TS 基础类型有哪些"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Array",
      "数组",
      "Data Structures",
      "数据结构"
    ],
    "difficulty": "Easy",
    "title": "数组 Array 和元组 Tuple 的区别是什么"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Easy",
    "title": "枚举 enum 是什么？有什么使用场景？"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "keyof 和 typeof 有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "any void never unknown 有什么区别"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "unknown 和 any 区别"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "TS 访问修饰符 public protected private 有什么作用"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "type 和 interface 共同和区别，如何选择"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "什么是泛型，如何使用它？"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "什么是交叉类型和联合类型"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "是否用过工具类型"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "TS 这些符号 ? ?. ?? ! _ & | # 分别什么意思"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Medium",
    "title": "什么是抽象类 abstract class"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Fundamentals",
      "基础"
    ],
    "difficulty": "Hard",
    "title": "如何扩展 window 属性，如何定义第三方模块的类型"
  },
  {
    "type": "Question",
    "category": [
      "TypeScript",
      "TypeScript",
      "Experience",
      "经验"
    ],
    "difficulty": "Medium",
    "title": "是否有过真实的 Typescript 开发经验，讲一下你的使用体验"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "TCP 是如何建立连接的，三次握手，四次挥手"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "HTTP 几个版本的区别"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "HTTP 常见的状态码"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "HTTP 常见 Header"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "URL 包含哪些部分？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Easy",
    "title": "GET 和 POST 请求的区别"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "Ajax Fetch Axios 三者有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "Fetch 和 XMLHTTPRequest 有什么区别？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "什么是 Restful API ？"
  },
  {
    "type": "Question",
    "category": [
      "Networking",
      "网络",
      "HTTP",
      "HTTP"
    ],
    "difficulty": "Medium",
    "title": "什么是 GraphQL ？"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Hash Table",
      "哈希表"
    ],
    "difficulty": "Easy",
    "title": "1. 两数之和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "String",
      "字符串"
    ],
    "difficulty": "Medium",
    "title": "49. 字母异位词分组"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "128. 最长连续序列"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Two Pointers",
      "双指针"
    ],
    "difficulty": "Easy",
    "title": "283. 移动零"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "11. 盛最多水的容器"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "15. 三数之和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Hard",
    "title": "42. 接雨水"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "String",
      "字符串",
      "Sliding Window",
      "滑动窗口"
    ],
    "difficulty": "Medium",
    "title": "3. 无重复字符的最长子串"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "String",
      "字符串"
    ],
    "difficulty": "Medium",
    "title": "438. 找到字符串中所有字母异位词"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "560. 和为 K 的子数组"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Sliding Window",
      "滑动窗口"
    ],
    "difficulty": "Hard",
    "title": "239. 滑动窗口最大值"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "String",
      "字符串",
      "Sliding Window",
      "滑动窗口"
    ],
    "difficulty": "Hard",
    "title": "76. 最小覆盖子串"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "53. 最大子数组和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "56. 合并区间"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "189. 轮转数组"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "238. 除自身以外数组的乘积"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Hard",
    "title": "41. 缺失的第一个正数"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Matrix",
      "矩阵"
    ],
    "difficulty": "Medium",
    "title": "73. 矩阵置零"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Matrix",
      "矩阵"
    ],
    "difficulty": "Medium",
    "title": "54. 螺旋矩阵"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Matrix",
      "矩阵"
    ],
    "difficulty": "Medium",
    "title": "48. 旋转图像"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Matrix",
      "矩阵"
    ],
    "difficulty": "Medium",
    "title": "240. 搜索二维矩阵 II"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "160. 相交链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "206. 反转链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "234. 回文链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "141. 环形链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Medium",
    "title": "142. 环形链表 II"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Easy",
    "title": "21. 合并两个有序链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Medium",
    "title": "2. 两数相加"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Medium",
    "title": "19. 删除链表的倒数第 N 个结点"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Medium",
    "title": "24. 两两交换链表中的节点"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Hard",
    "title": "25. K 个一组翻转链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Medium",
    "title": "138. 随机链表的复制"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表",
      "Sorting",
      "排序"
    ],
    "difficulty": "Medium",
    "title": "148. 排序链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Linked List",
      "链表"
    ],
    "difficulty": "Hard",
    "title": "23. 合并 K 个升序链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Medium",
    "title": "146. LRU 缓存"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Easy",
    "title": "94. 二叉树的中序遍历"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Easy",
    "title": "104. 二叉树的最大深度"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Easy",
    "title": "226. 翻转二叉树"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Easy",
    "title": "101. 对称二叉树"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Easy",
    "title": "543. 二叉树的直径"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "102. 二叉树的层序遍历"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树",
      "Binary Search Tree",
      "二叉搜索树"
    ],
    "difficulty": "Easy",
    "title": "108. 将有序数组转换为二叉搜索树"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树",
      "Binary Search Tree",
      "二叉搜索树"
    ],
    "difficulty": "Medium",
    "title": "98. 验证二叉搜索树"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树",
      "Binary Search Tree",
      "二叉搜索树"
    ],
    "difficulty": "Medium",
    "title": "230. 二叉搜索树中第 K 小的元素"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "199. 二叉树的右视图"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "114. 二叉树展开为链表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "105. 从前序与中序遍历序列构造二叉树"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "437. 路径总和 III"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Medium",
    "title": "236. 二叉树的最近公共祖先"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Tree",
      "二叉树"
    ],
    "difficulty": "Hard",
    "title": "124. 二叉树中的最大路径和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Graph",
      "图"
    ],
    "difficulty": "Medium",
    "title": "200. 岛屿数量"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Graph",
      "图"
    ],
    "difficulty": "Medium",
    "title": "994. 腐烂的橘子"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Graph",
      "图"
    ],
    "difficulty": "Medium",
    "title": "207. 课程表"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Trie",
      "前缀树"
    ],
    "difficulty": "Medium",
    "title": "208. 实现 Trie (前缀树)"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "46. 全排列"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "78. 子集"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "17. 电话号码的字母组合"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "39. 组合总和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "22. 括号生成"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "79. 单词搜索"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Medium",
    "title": "131. 分割回文串"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Backtracking",
      "回溯"
    ],
    "difficulty": "Hard",
    "title": "51. N 皇后"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找"
    ],
    "difficulty": "Easy",
    "title": "35. 搜索插入位置"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找",
      "Matrix",
      "矩阵"
    ],
    "difficulty": "Medium",
    "title": "74. 搜索二维矩阵"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找"
    ],
    "difficulty": "Medium",
    "title": "34. 在排序数组中查找元素的第一个和最后一个位置"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找"
    ],
    "difficulty": "Medium",
    "title": "33. 搜索旋转排序数组"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找"
    ],
    "difficulty": "Medium",
    "title": "153. 寻找旋转排序数组中的最小值"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Binary Search",
      "二分查找"
    ],
    "difficulty": "Hard",
    "title": "4. 寻找两个正序数组的中位数"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Stack",
      "栈"
    ],
    "difficulty": "Easy",
    "title": "20. 有效的括号"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Stack",
      "栈"
    ],
    "difficulty": "Medium",
    "title": "155. 最小栈"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Stack",
      "栈",
      "String",
      "字符串"
    ],
    "difficulty": "Medium",
    "title": "394. 字符串解码"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Stack",
      "栈"
    ],
    "difficulty": "Medium",
    "title": "739. 每日温度"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Stack",
      "栈"
    ],
    "difficulty": "Hard",
    "title": "84. 柱状图中最大的矩形"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Heap",
      "堆"
    ],
    "difficulty": "Medium",
    "title": "215. 数组中的第K个最大元素"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Heap",
      "堆",
      "Hash Table",
      "哈希表"
    ],
    "difficulty": "Medium",
    "title": "347. 前 K 个高频元素"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Heap",
      "堆",
      "System Design",
      "系统设计"
    ],
    "difficulty": "Hard",
    "title": "295. 数据流的中位数"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Greedy",
      "贪心算法"
    ],
    "difficulty": "Easy",
    "title": "121. 买卖股票的最佳时机"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Greedy",
      "贪心算法"
    ],
    "difficulty": "Medium",
    "title": "55. 跳跃游戏"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Greedy",
      "贪心算法"
    ],
    "difficulty": "Medium",
    "title": "45. 跳跃游戏 II"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Greedy",
      "贪心算法"
    ],
    "difficulty": "Medium",
    "title": "763. 划分字母区间"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Easy",
    "title": "70. 爬楼梯"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Easy",
    "title": "118. 杨辉三角"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "198. 打家劫舍"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "279. 完全平方数"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "322. 零钱兑换"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "139. 单词拆分"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "300. 最长递增子序列"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "152. 乘积最大子数组"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "416. 分割等和子集"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Hard",
    "title": "32. 最长有效括号"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "62. 不同路径"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "64. 最小路径和"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划",
      "String",
      "字符串"
    ],
    "difficulty": "Medium",
    "title": "5. 最长回文子串"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "1143. 最长公共子序列"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Dynamic Programming",
      "动态规划"
    ],
    "difficulty": "Medium",
    "title": "72. 编辑距离"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Bit Manipulation",
      "位运算"
    ],
    "difficulty": "Easy",
    "title": "136. 只出现一次的数字"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Easy",
    "title": "169. 多数元素"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组",
      "Sorting",
      "排序"
    ],
    "difficulty": "Medium",
    "title": "75. 颜色分类"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "31. 下一个排列"
  },
  {
    "type": "Coding",
    "category": [
      "LeetCode Hot 100",
      "LeetCode",
      "LeetCode",
      "Array",
      "数组"
    ],
    "difficulty": "Medium",
    "title": "287. 寻找重复数"
  },
  {
    "type": "Coding",
    "category": [
      "Concurrency",
      "并发",
      "Java",
      "Java"
    ],
    "difficulty": "Medium",
    "title": "Java两个线程交叉打印"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MQ"
    ],
    "difficulty": "Medium",
    "title": "为什么使用消息队列？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "MQ"
    ],
    "difficulty": "Medium",
    "title": "消息队列有什么优点和缺点？"
  },
  {
    "type": "Question",
    "category": [
      "Database",
      "数据库",
      "System Design",
      "系统设计",
      "MQ",
      "Kafka",
      "RocketMQ"
    ],
    "difficulty": "Hard",
    "title": "Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么区别，以及适合哪些场景？"
  }
]